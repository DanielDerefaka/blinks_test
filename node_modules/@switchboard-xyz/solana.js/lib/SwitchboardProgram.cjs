"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnchorWallet = exports.isVersionedTransaction = exports.SwitchboardProgram = exports.getSwitchboardAttestationProgramId = exports.getSwitchboardProgramId = exports.READ_ONLY_KEYPAIR = exports.SB_ATTESTATION_PID = exports.SB_V2_PID = exports.DEFAULT_SEND_TRANSACTION_OPTIONS = void 0;
const index_js_1 = require("./accounts/index.cjs");
const index_js_2 = require("./generated/index.cjs");
const const_js_1 = require("./const.cjs");
const errors = __importStar(require("./errors.cjs"));
const mint_js_1 = require("./mint.cjs");
const TransactionObject_js_1 = require("./TransactionObject.cjs");
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const common_1 = require("@switchboard-xyz/common");
exports.DEFAULT_SEND_TRANSACTION_OPTIONS = {
    skipPreflight: false,
    maxRetries: 10,
    skipConfrimation: false,
};
/**
 * Switchboard's V2 Program ID
 */
exports.SB_V2_PID = new web3_js_1.PublicKey("SW1TCH7qEPTdLsDHRgPuMQjbQxKdH2aBStViMFnt64f");
/**
 * Switchboard's Attestation Program ID
 */
exports.SB_ATTESTATION_PID = new web3_js_1.PublicKey("sbattyXrzedoNATfc4L31wC9Mhxsi1BmFhTiN8gDshx");
/**
 *  A generated keypair that is assigned as the _payerKeypair_ when in read-only mode.
 */
exports.READ_ONLY_KEYPAIR = web3_js_1.Keypair.generate();
/**
 * Returns the Switchboard Program ID for the specified Cluster.
 */
const getSwitchboardProgramId = (cluster) => {
    switch (cluster) {
        case "localnet":
        case "devnet":
        case "mainnet-beta":
            return exports.SB_V2_PID;
        case "testnet":
        default:
            throw new Error(`Switchboard PID not found for cluster (${cluster})`);
    }
};
exports.getSwitchboardProgramId = getSwitchboardProgramId;
/**
 * Returns the Program ID for the Switchboard Attestation Program for the specified Cluster.
 */
const getSwitchboardAttestationProgramId = (cluster) => {
    switch (cluster) {
        case "localnet":
        case "devnet":
        case "mainnet-beta":
            return exports.SB_ATTESTATION_PID;
        case "testnet":
        default:
            throw new Error(`Switchboard Attestation PID not found for cluster (${cluster})`);
    }
};
exports.getSwitchboardAttestationProgramId = getSwitchboardAttestationProgramId;
/**
 * Wrapper class for the Switchboard anchor Program.
 *
 * This class provides an interface to interact with the Switchboard program on the Solana network.
 * It allows you to load the program, create and initialize connection objects, and interact with
 * Switchboard accounts.
 *
 * Basic usage example:
 *
 * ```ts
 * import { Connection } from "@solana/web3.js";
 * import { SwitchboardProgram, TransactionObject } from '@switchboard-xyz/solana.js';
 *
 * const program = await SwitchboardProgram.load(
 *    "mainnet-beta",
 *    new Connection("https://api.mainnet-beta.solana.com"),
 *    payerKeypair
 * );
 *
 * const txn = new TransactionObject(program.walletPubkey, [], []);
 * const txnSignature = await program.signAndSend(txn);
 * ```
 */
class SwitchboardProgram {
    // The read-only keypair for the Switchboard program.
    static _readOnlyKeypair = exports.READ_ONLY_KEYPAIR;
    // The anchor program instance.
    _program;
    // The anchor program instance for Switchboard's attestation program.
    _attestationProgram;
    /** The Solana cluster to load the Switchboard program for. */
    cluster;
    // The pubkey and bump of the Switchboard program state account.
    programState;
    // The pubkey and bump of the Switchboard quote verifier program state account.
    attestationProgramState;
    // The native mint for the Switchboard program.
    mint;
    /**
     * Constructor for the SwitchboardProgram class.
     *
     * @param program - The anchor program instance.
     * @param cluster - The Solana cluster to load the Switchboard program for.
     * @param mint - The native mint for the Switchboard program.
     */
    constructor(program, attestationProgram, cluster, mint) {
        this._program = program;
        this._attestationProgram = attestationProgram;
        this.cluster = cluster;
        // Derive the state account from the seed.
        const stateAccount = index_js_1.ProgramStateAccount.fromSeed(this);
        this.programState = {
            publicKey: stateAccount[0].publicKey,
            bump: stateAccount[1],
        };
        this.programState = {
            publicKey: stateAccount[0].publicKey,
            bump: stateAccount[1],
        };
        // TODO: produce the attestation state account from the seed.
        if (this._attestationProgram) {
            const attestationStateAccount = index_js_1.AttestationProgramStateAccount.fromSeed(this);
            this.attestationProgramState = {
                publicKey: attestationStateAccount[0].publicKey,
                bump: attestationStateAccount[1],
            };
        }
        else {
            const [attestationProgramStatePubkey, attestationProgramStateBump] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("STATE")], exports.SB_ATTESTATION_PID);
            this.attestationProgramState = {
                publicKey: attestationProgramStatePubkey,
                bump: attestationProgramStateBump,
            };
        }
        this.mint = mint;
    }
    /**
     * Load the anchor program for the Switchboard.
     *
     * This method fetches the IDL for the Switchboard program, and initializes an anchor program
     * instance using the fetched IDL, provided program ID, and provider.
     *
     * @param cluster - The Solana cluster to load the Switchboard program for.
     * @param connection - The Solana connection object used to connect to an RPC node.
     * @param payerKeypair - Optional payer keypair used to pay for on-chain transactions.
     * @param programId - Optional program ID to override the cluster's default programId.
     *
     * @returns The initialized anchor program instance for the Switchboard.
     */
    static async loadAnchorProgram(cluster, connection, payerKeypair = exports.READ_ONLY_KEYPAIR, programId) {
        const pid = programId ?? (0, exports.getSwitchboardProgramId)(cluster);
        const provider = new anchor_1.AnchorProvider(connection, 
        // If no keypair is provided, default to dummy keypair
        new AnchorWallet(payerKeypair ?? SwitchboardProgram._readOnlyKeypair), { commitment: "confirmed" });
        const anchorIdl = await anchor_1.Program.fetchIdl(pid, provider);
        if (!anchorIdl) {
            throw new Error(`Failed to find IDL for ${pid.toBase58()}`);
        }
        const program = new anchor_1.Program(anchorIdl, pid, provider);
        return program;
    }
    /**
     * Create and initialize a {@linkcode SwitchboardProgram} connection object.
     *
     * @param cluster - the solana cluster to load the Switchboard program for.
     *
     * @param connection - the Solana connection object used to connect to an RPC node.
     *
     * @param payerKeypair - optional, payer keypair used to pay for on-chain transactions.
     *
     * @param programId - optional, override the cluster's default programId.
     *
     * @return the {@linkcode SwitchboardProgram} used to create and interact with Switchboard accounts.
     *
     * Basic usage example:
     *
     * ```ts
     * import { Connection } from "@solana/web3.js";
     * import { SwitchboardProgram, TransactionObject } from '@switchboard-xyz/solana.js';
     *
     * const program = await SwitchboardProgram.load(
     *    "mainnet-beta",
     *    new Connection("https://api.mainnet-beta.solana.com"),
     *    payerKeypair
     * );
     *
     * const txn = new TransactionObject(program.walletPubkey, [], []);
     * const txnSignature = await program.signAndSend(txn);
     * ```
     */
    static load = async (cluster, connection, payerKeypair = exports.READ_ONLY_KEYPAIR, programId = (0, exports.getSwitchboardProgramId)(cluster), attestationProgramId = (0, exports.getSwitchboardAttestationProgramId)(cluster)) => {
        const [program, attestationProgram] = await Promise.all([
            SwitchboardProgram.loadAnchorProgram(cluster, connection, payerKeypair, programId),
            SwitchboardProgram.loadAnchorProgram(cluster, connection, payerKeypair, attestationProgramId),
        ]);
        const mint = await mint_js_1.NativeMint.load(program.provider);
        return new SwitchboardProgram(program, attestationProgram, cluster, mint);
    };
    // public verifyAttestation(): void {
    //   if (this._attestationProgram === undefined) {
    //     throw new Error(`Attestation Program is missing`);
    //   }
    // }
    /**
     * Create and initialize a {@linkcode SwitchboardProgram} connection object.
     *
     * @param provider - The anchor provider containing the RPC and wallet connection.
     *
     * @return The {@linkcode SwitchboardProgram} used to create and interact with Switchboard accounts.
     *
     * Basic usage example:
     *
     * ```ts
     * import * as anchor from "@coral-xyz/anchor";
     * import { Connection } from "@solana/web3.js";
     * import { AnchorWallet, SwitchboardProgram, TransactionObject } from '@switchboard-xyz/solana.js';
     *
     * const connection = new Connection("https://api.mainnet-beta.solana.com");
     * const provider = new AnchorProvider(
        connection,
        new AnchorWallet(payerKeypair ?? SwitchboardProgram._readOnlyKeypair),
        { commitment: 'confirmed' }
      );
     * const program = await SwitchboardProgram.fromProvider(provider);
     *
     * const txn = new TransactionObject(program.walletPubkey, [], []);
     * const txnSignature = await program.signAndSend(txn);
     * ```
     */
    static fromProvider = async (provider, programId, attestationProgramId) => {
        const payer = provider.wallet.payer;
        const program = await SwitchboardProgram.fromConnection(provider.connection, payer, programId, attestationProgramId);
        return program;
    };
    /**
     * Create and initialize a {@linkcode SwitchboardProgram} connection object.
     *
     * @param connection - The Solana connection object used to connect to an RPC node.
     * @param payer - Optional, payer keypair used to pay for on-chain transactions (defaults to READ_ONLY_KEYPAIR).
     * @param programId - Optional, override the cluster's default programId.
     *
     * @return The {@linkcode SwitchboardProgram} instance used to create and interact with Switchboard accounts.
     *
     * Basic usage example:
     *
     * ```ts
     * import * as anchor from "@coral-xyz/anchor";
     * import { Connection } from "@solana/web3.js";
     * import { AnchorWallet, SwitchboardProgram, TransactionObject } from '@switchboard-xyz/solana.js';
     *
     * const connection = new Connection("https://api.mainnet-beta.solana.com");
     * const program = await SwitchboardProgram.fromConnection(connection);
     * ```
     */
    static fromConnection = async (connection, payer = exports.READ_ONLY_KEYPAIR, programId, attestationProgramId) => {
        const genesisHash = await connection.getGenesisHash();
        const cluster = genesisHash === const_js_1.MAINNET_GENESIS_HASH
            ? "mainnet-beta"
            : genesisHash === const_js_1.DEVNET_GENESIS_HASH
                ? "devnet"
                : "localnet";
        const pid = programId ?? exports.SB_V2_PID;
        const programAccountInfo = await connection.getAccountInfo(pid);
        if (programAccountInfo === null) {
            throw new Error(`Failed to load Switchboard V2 program at ${pid}, try manually providing a programId`);
        }
        const attestationPid = attestationProgramId ?? exports.SB_ATTESTATION_PID;
        const attestationProgramAccountInfo = await connection.getAccountInfo(attestationPid);
        if (attestationProgramAccountInfo === null) {
            throw new Error(`Failed to load Switchboard Attestation program at ${attestationPid}, try manually providing a programId`);
        }
        const program = await SwitchboardProgram.load(cluster, connection, payer, pid, attestationPid);
        return program;
    };
    async getGitVersion() {
        const messageV0 = new web3_js_1.TransactionMessage({
            payerKey: this.walletPubkey,
            instructions: [
                await this._program.methods.viewVersion().accounts({}).instruction(),
            ],
            recentBlockhash: (await this.connection.getLatestBlockhash()).blockhash,
        }).compileToLegacyMessage();
        const simulationResult = await this.connection.simulateTransaction(new web3_js_1.VersionedTransaction(messageV0), { sigVerify: false });
        const logs = (simulationResult.value?.logs ?? []).join("\n");
        const version = extractVersion(logs);
        if (version) {
            return version;
        }
        throw new Error(`Failed to yield the git version in the view_version simulation result`);
    }
    async getAttestationGitVersion() {
        const messageV0 = new web3_js_1.TransactionMessage({
            payerKey: this.walletPubkey,
            instructions: [
                await this._attestationProgram.methods
                    .viewVersion()
                    .accounts({})
                    .instruction(),
            ],
            recentBlockhash: (await this.connection.getLatestBlockhash()).blockhash,
        }).compileToLegacyMessage();
        const simulationResult = await this.connection.simulateTransaction(new web3_js_1.VersionedTransaction(messageV0), { sigVerify: false });
        const logs = (simulationResult.value?.logs ?? []).join("\n");
        const version = extractVersion(logs);
        if (version) {
            return version;
        }
        throw new Error(`Failed to yield the git version in the view_version simulation result`);
    }
    /**
     * Retrieves the Switchboard V2 Program ID for the currently connected cluster.
     * @return The PublicKey of the Switchboard V2 Program ID.
     */
    get programId() {
        return this._program.programId;
    }
    /**
     * Retrieves the Switchboard Attestation Program ID for the currently connected cluster.
     * @return The PublicKey of the Switchboard Attestation Program ID.
     */
    get attestationProgramId() {
        return this._attestationProgram.programId;
    }
    /**
     * Retrieves the Switchboard V2 Program IDL.
     * @return The IDL of the Switchboard V2 Program.
     */
    get idl() {
        return this._program.idl;
    }
    /**
     * Retrieves the Switchboard Attestation Program IDL.
     * @return The IDL of the Switchboard Attestation Program.
     */
    get attestationIdl() {
        return this._program.idl;
    }
    /**
     * Retrieves the Switchboard V2 Borsh Accounts Coder.
     * @return The BorshAccountsCoder for the Switchboard V2 Program.
     */
    get coder() {
        return new anchor_1.BorshAccountsCoder(this._program.idl);
    }
    /**
     * Retrieves the Switchboard Attestatio Borsh Accounts Coder.
     * @return The BorshAccountsCoder for the Switchboard Attestation Program.
     */
    get attestationCoder() {
        return new anchor_1.BorshAccountsCoder(this._attestationProgram.idl);
    }
    /**
     * Retrieves the anchor Provider used by this program to connect with the Solana cluster.
     * @return The AnchorProvider instance for the Switchboard Program.
     */
    get provider() {
        return this._program.provider;
    }
    /**
     * Retrieves the Connection used by this program to connect with the Solana cluster.
     * @return The Connection instance for the Switchboard Program.
     */
    get connection() {
        return this.provider.connection;
    }
    /**
     * Retrieves the Wallet used by this program.
     * @return The AnchorWallet instance for the Switchboard Program.
     */
    get wallet() {
        return this.provider.wallet;
    }
    /**
     * Retrieves the wallet's PublicKey.
     * @return The PublicKey of the wallet.
     */
    get walletPubkey() {
        return this.wallet.payer.publicKey;
    }
    /**
     * Returns a new instance of the SwitchboardProgram class for a new payer keypair
     * @return A new instance of the SwitchboardProgram class
     */
    newWithPayer(payer) {
        const newProvider = new anchor_1.AnchorProvider(this.connection, new AnchorWallet(payer), this.provider.opts);
        const program = new anchor_1.Program(this._program.idl, this._program.programId, newProvider);
        const attestationProgram = new anchor_1.Program(this._attestationProgram.idl, this._attestationProgram.programId, newProvider);
        return new SwitchboardProgram(program, attestationProgram, this.cluster, this.mint);
    }
    /**
     * Checks if the program is read-only.
     * @return A boolean indicating if the SwitchboardProgram instance is read-only.
     */
    get isReadOnly() {
        return (this.provider.publicKey.toBase58() ===
            SwitchboardProgram._readOnlyKeypair.publicKey.toBase58());
    }
    /**
     * Verifies that a payer keypair has been supplied to the {@linkcode SwitchboardProgram}.
     * Throws an error if the program is read-only.
     */
    verifyPayer() {
        if (this.isReadOnly) {
            throw new errors.SwitchboardProgramReadOnlyError();
        }
    }
    /**
     * Verifies that a new keypair has been provided and the corresponding account does not already exist.
     *
     * **NOTE:** Creating new accounts without this check may prevent the ability to withdraw any existing funds.
     *
     * @param keypair - The Keypair to be verified.
     * @throws Will throw an error if the account for the keypair already exists.
     */
    async verifyNewKeypair(keypair) {
        const accountInfo = await this.connection.getAccountInfo(keypair.publicKey);
        if (accountInfo) {
            throw new errors.ExistingKeypair();
        }
    }
    /**
     * Verifies that a new keypair has been provided and the corresponding account does not already exist.
     *
     * **NOTE:** Creating new accounts without this check may prevent the ability to withdraw any existing funds.
     *
     * @param keypair - The Keypair to be verified.
     * @throws Will throw an error if the account for the keypair already exists.
     */
    async verifyNewKeypairs(...keypairs) {
        const accounts = await this.connection.getMultipleAccountsInfo(keypairs.map((k) => k.publicKey));
        for (const [n, account] of accounts.entries()) {
            if (account) {
                throw new errors.ExistingKeypair();
            }
        }
    }
    /**
     * Retrieves the account namespace for the Switchboard V2 Program.
     * @return The AccountNamespace instance for the Switchboard V2 Program.
     */
    get account() {
        return this._program.account;
    }
    /**
     * Retrieves the account namespace for the Switchboard Attestation Program.
     * @return The AccountNamespace instance for the Switchboard Attestation Program.
     */
    get attestationAccount() {
        return this._attestationProgram.account;
    }
    /**
     * Load the Switchboard Labs permissionless Queue for either devnet or mainnet. The permissionless queue has the following permissions:
     *  - unpermissionedFeedsEnabled: True
     *  - unpermissionedVrfEnabled: True
     *  - enableBufferRelayers: False
     *
     * **Note:** {@linkcode AggregatorAccount}s and {@linkcode VrfAccount}s do not require permissions to join this queue. {@linkcode BufferRelayerAccount}s are disabled.
     */
    async loadPermissionless() {
        const queueKey = this.cluster === "mainnet-beta"
            ? const_js_1.SWITCHBOARD_LABS_MAINNET_PERMISSIONLESS_QUEUE
            : this.cluster === "devnet"
                ? const_js_1.SWITCHBOARD_LABS_DEVNET_PERMISSIONLESS_QUEUE
                : null;
        if (!queueKey) {
            throw new Error(`Failed to load the permissionless queue for cluster ${this.cluster}`);
        }
        const [queueAccount, queue] = await index_js_1.QueueAccount.load(this, queueKey);
        const crankKey = this.cluster === "mainnet-beta"
            ? const_js_1.SWITCHBOARD_LABS_MAINNET_PERMISSIONLESS_CRANK
            : this.cluster === "devnet"
                ? const_js_1.SWITCHBOARD_LABS_DEVNET_PERMISSIONLESS_CRANK
                : null;
        if (!crankKey) {
            throw new Error(`Failed to load the permissionless queue for cluster ${this.cluster}`);
        }
        const [crankAccount, crank] = await index_js_1.CrankAccount.load(this, crankKey);
        return { queueAccount, queue, crankAccount, crank };
    }
    /**
     * Load the Switchboard Labs permissionled Queue for either devnet or mainnet. The permissioned queue has the following permissions:
     *  - unpermissionedFeedsEnabled: False
     *  - unpermissionedVrfEnabled: False
     *  - enableBufferRelayers: False
     *
     * **Note:** The queue authority must grant {@linkcode AggregatorAccount}s PERMIT_ORACLE_QUEUE_USAGE and {@linkcode VrfAccount}s PERMIT_VRF_REQUESTS permissions before joining the queue and requesting oracle updates. {@linkcode BufferRelayerAccount}s are disabled.
     */
    async loadPermissioned() {
        const queueKey = this.cluster === "mainnet-beta"
            ? const_js_1.SWITCHBOARD_LABS_MAINNET_PERMISSIONED_QUEUE
            : this.cluster === "devnet"
                ? const_js_1.SWITCHBOARD_LABS_DEVNET_PERMISSIONED_QUEUE
                : null;
        if (!queueKey) {
            throw new Error(`Failed to load the permissioned queue for cluster ${this.cluster}`);
        }
        const [queueAccount, queue] = await index_js_1.QueueAccount.load(this, this.cluster === "mainnet-beta"
            ? const_js_1.SWITCHBOARD_LABS_MAINNET_PERMISSIONED_QUEUE
            : const_js_1.SWITCHBOARD_LABS_DEVNET_PERMISSIONED_QUEUE);
        const crankKey = this.cluster === "mainnet-beta"
            ? const_js_1.SWITCHBOARD_LABS_MAINNET_PERMISSIONED_CRANK
            : this.cluster === "devnet"
                ? const_js_1.SWITCHBOARD_LABS_DEVNET_PERMISSIONED_CRANK
                : null;
        if (!crankKey) {
            throw new Error(`Failed to load the permissionless queue for cluster ${this.cluster}`);
        }
        const [crankAccount, crank] = await index_js_1.CrankAccount.load(this, crankKey);
        return { queueAccount, queue, crankAccount, crank };
    }
    /**
     * Adds an event listener for the specified AnchorEvent, allowing consumers to monitor the chain for events
     * such as AggregatorOpenRound, VrfRequestRandomness, and AggregatorSaveResult.
     *
     * @param eventName - The name of the event to listen for.
     * @param callback - A callback function to handle the event data, slot, and signature.
     * @return A unique listener ID that can be used to remove the event listener.
     */
    addEventListener(eventName, callback) {
        return this._program.addEventListener(eventName, callback);
    }
    /**
     * Removes the event listener with the specified listener ID.
     *
     * @param listenerId - The unique ID of the event listener to be removed.
     */
    async removeEventListener(listenerId) {
        return await this._program.removeEventListener(listenerId);
    }
    /**
     * Adds an event listener for the specified AnchorEvent, allowing consumers to monitor the chain for events
     * emitted from Switchboard's attestation program.
     *
     * @param eventName - The name of the event to listen for.
     * @param callback - A callback function to handle the event data, slot, and signature.
     * @return A unique listener ID that can be used to remove the event listener.
     */
    addAttestationEventListener(eventName, callback) {
        return this._attestationProgram.addEventListener(eventName, callback);
    }
    /**
     * Removes the event listener with the specified listener ID.
     *
     * @param listenerId - The unique ID of the event listener to be removed.
     */
    async removeAttestationEventListener(listenerId) {
        return await this._attestationProgram.removeEventListener(listenerId);
    }
    async signAndSendAll(txns, opts = exports.DEFAULT_SEND_TRANSACTION_OPTIONS, txnOptions, delay = 0) {
        const txnSignatures = await TransactionObject_js_1.TransactionObject.signAndSendAll(this.provider, txns, opts, txnOptions, delay);
        return txnSignatures;
    }
    async signAndSend(txn, opts = exports.DEFAULT_SEND_TRANSACTION_OPTIONS, txnOptions) {
        const txnSignature = await txn.signAndSend(this.provider, opts, txnOptions);
        return txnSignature;
    }
    async getProgramJobAccounts() {
        const accountInfos = await this.connection
            .getProgramAccounts(this.programId, {
            filters: [
                {
                    memcmp: {
                        offset: 0,
                        bytes: anchor_1.utils.bytes.bs58.encode(index_js_2.JobAccountData.discriminator),
                    },
                },
            ],
        })
            .then((values) => {
            return values.filter(Boolean);
        });
        const jobs = accountInfos
            .map((job) => {
            const jobAccount = new index_js_1.JobAccount(this, job.pubkey);
            const state = index_js_2.JobAccountData.decode(job.account.data);
            let oracleJob;
            try {
                oracleJob = common_1.OracleJob.decodeDelimited(state.data);
            }
            catch {
                return undefined;
            }
            return {
                account: jobAccount,
                state: state,
                job: oracleJob,
            };
        })
            .filter(Boolean);
        return new Map(jobs.map((job) => [job.state.data, job]));
    }
    async getProgramAccounts() {
        const accountInfos = await this.connection.getProgramAccounts(this.programId);
        // buffer - [42, 55, 46, 46, 45, 52, 78, 78]
        // bufferRelayer - [50, 35, 51, 115, 169, 219, 158, 52]
        // lease - [55, 254, 208, 251, 164, 44, 150, 50]
        // permissions - [77, 37, 177, 164, 38, 39, 34, 109]
        // slidingResult - [91, 4, 83, 187, 102, 216, 153, 254]
        // vrf - [101, 35, 62, 239, 103, 151, 6, 18]
        // crank - [111, 81, 146, 73, 172, 180, 134, 209]
        // job - [124, 69, 101, 195, 229, 218, 144, 63]
        // oracles - [128, 30, 16, 241, 170, 73, 55, 54]
        // sbState - [159, 42, 192, 191, 139, 62, 168, 28]
        // queue - [164, 207, 200, 51, 199, 113, 35, 109]
        // aggregator - [217, 230, 65, 101, 201, 162, 27, 125]
        const discriminatorMap = accountInfos.reduce((map, account) => {
            const discriminator = account.account.data
                .slice(0, anchor_1.ACCOUNT_DISCRIMINATOR_SIZE)
                .toString("utf-8");
            const accounts = map.get(discriminator) ?? [];
            accounts.push(account);
            map.set(discriminator, accounts);
            return map;
        }, new Map());
        function decodeAccounts(accounts, decode) {
            return accounts.reduce((map, account) => {
                try {
                    const decoded = decode(account.account.data);
                    map.set(account.pubkey.toBase58(), decoded);
                    // eslint-disable-next-line no-empty
                }
                catch { }
                return map;
            }, new Map());
        }
        const aggregators = decodeAccounts(discriminatorMap.get(index_js_2.AggregatorAccountData.discriminator.toString("utf-8")) ?? [], index_js_2.AggregatorAccountData.decode);
        // TODO: Use aggregator.historyBuffer, crank.dataBuffer, queue.dataBuffer to filter these down and decode
        const buffers = (discriminatorMap.get(index_js_1.BUFFER_DISCRIMINATOR.toString("utf-8")) ?? []).reduce((map, buffer) => {
            map.set(buffer.pubkey.toBase58(), buffer.account.data);
            return map;
        }, new Map());
        const bufferRelayers = decodeAccounts(discriminatorMap.get(index_js_2.BufferRelayerAccountData.discriminator.toString("utf-8")) ?? [], index_js_2.BufferRelayerAccountData.decode);
        const cranks = decodeAccounts(discriminatorMap.get(index_js_2.CrankAccountData.discriminator.toString("utf-8")) ??
            [], index_js_2.CrankAccountData.decode);
        const jobs = decodeAccounts(discriminatorMap.get(index_js_2.JobAccountData.discriminator.toString("utf-8")) ??
            [], index_js_2.JobAccountData.decode);
        const leases = decodeAccounts(discriminatorMap.get(index_js_2.LeaseAccountData.discriminator.toString("utf-8")) ??
            [], index_js_2.LeaseAccountData.decode);
        const oracles = decodeAccounts(discriminatorMap.get(index_js_2.OracleAccountData.discriminator.toString("utf-8")) ??
            [], index_js_2.OracleAccountData.decode);
        const permissions = decodeAccounts(discriminatorMap.get(index_js_2.PermissionAccountData.discriminator.toString("utf-8")) ?? [], index_js_2.PermissionAccountData.decode);
        const programState = decodeAccounts(discriminatorMap.get(index_js_2.SbState.discriminator.toString("utf-8")) ?? [], index_js_2.SbState.decode);
        const queues = decodeAccounts(discriminatorMap.get(index_js_2.OracleQueueAccountData.discriminator.toString("utf-8")) ?? [], index_js_2.OracleQueueAccountData.decode);
        const slidingResult = decodeAccounts(discriminatorMap.get(index_js_2.SlidingResultAccountData.discriminator.toString("utf-8")) ?? [], index_js_2.SlidingResultAccountData.decode);
        const vrfs = decodeAccounts(discriminatorMap.get(index_js_2.VrfAccountData.discriminator.toString("utf-8")) ??
            [], index_js_2.VrfAccountData.decode);
        return {
            aggregators,
            buffers,
            bufferRelayers,
            cranks,
            jobs,
            leases,
            oracles,
            permissions,
            programState,
            slidingResult,
            queues,
            vrfs,
        };
    }
    static getAccountType(accountInfo) {
        const discriminator = accountInfo.data
            .slice(0, anchor_1.ACCOUNT_DISCRIMINATOR_SIZE)
            .toString("utf-8");
        const accountType = index_js_1.DISCRIMINATOR_MAP.get(discriminator);
        if (accountType) {
            return accountType;
        }
        return null;
    }
}
exports.SwitchboardProgram = SwitchboardProgram;
/**
 * Check if a transaction object is a VersionedTransaction or not
 *
 * @param tx
 * @returns bool
 */
const isVersionedTransaction = (tx) => {
    return "version" in tx;
};
exports.isVersionedTransaction = isVersionedTransaction;
class AnchorWallet {
    payer;
    constructor(payer) {
        this.payer = payer;
    }
    get publicKey() {
        return this.payer.publicKey;
    }
    async signTransaction(tx) {
        if ((0, exports.isVersionedTransaction)(tx)) {
            tx.sign([this.payer]);
        }
        else {
            tx.partialSign(this.payer);
        }
        return tx;
    }
    async signAllTransactions(txs) {
        return txs.map((t) => {
            if ((0, exports.isVersionedTransaction)(t)) {
                t.sign([this.payer]);
            }
            else {
                t.partialSign(this.payer);
            }
            return t;
        });
    }
}
exports.AnchorWallet = AnchorWallet;
function extractVersion(input) {
    const regex = /VERSION: (\S+)/;
    const match = input.match(regex);
    return match ? match[1] : null;
}
