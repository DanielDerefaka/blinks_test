import { Account } from "../accounts/account.js";
import * as errors from "../errors.js";
import * as types from "../generated/attestation-program/index.js";
import { SB_ATTESTATION_PID, SB_V2_PID } from "../SwitchboardProgram.js";
import { TransactionObject } from "../TransactionObject.js";
import { containsMrEnclave, handleOptionalPubkeys, numToBN, parseCronSchedule, parseRawBuffer, } from "../utils.js";
import { AttestationPermissionAccount, AttestationQueueAccount, FunctionRequestAccount, SwitchboardWallet, } from "./index.js";
import * as anchor from "@coral-xyz/anchor";
import * as spl from "@solana/spl-token";
import { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, } from "@solana/spl-token";
import { ComputeBudgetProgram, PublicKey, SystemProgram, } from "@solana/web3.js";
import { BN, parseRawMrEnclave, toUtf8 } from "@switchboard-xyz/common";
import assert from "assert";
const addressLookupProgram = new PublicKey("AddressLookupTab1e1111111111111111111111111");
/**
 * Account type representing a Switchboard Function.
 *
 * Data: {@linkcode types.FunctionAccountData}
 */
class FunctionAccount extends Account {
    static accountName = "FunctionAccountData";
    _wallet = undefined;
    /**
     *  Returns the functions's name buffer in a stringified format.
     */
    static getName = (functionState) => toUtf8(functionState.name);
    /**
     *  Returns the functions's metadata buffer in a stringified format.
     */
    static getMetadata = (functionState) => toUtf8(functionState.metadata);
    /**
     * Get the size of an {@linkcode FunctionAccount} on-chain.
     */
    size = this.program.attestationAccount.functionAccountData.size;
    get wallet() {
        if (!this._wallet) {
            this._wallet = this.loadData().then((fnState) => {
                return new SwitchboardWallet(this.program, fnState.escrowWallet);
            });
        }
        return this._wallet;
    }
    set wallet(_wallet) {
        this._wallet = _wallet;
    }
    static fromSeed(program, creatorSeed, recentSlot) {
        if (creatorSeed.length > 32) {
            throw new Error("Creator seed must be 32 bytes or less");
        }
        const functionPubkey = anchor.web3.PublicKey.findProgramAddressSync([
            Buffer.from("FunctionAccountData"),
            creatorSeed.length < 32 ? parseRawBuffer(creatorSeed, 32) : creatorSeed,
            recentSlot.toBuffer("le", 8),
        ], program.attestationProgramId)[0];
        return new FunctionAccount(program, functionPubkey);
    }
    async getBalance() {
        const wallet = await this.wallet;
        const balance = await wallet.getBalance();
        return balance;
    }
    async getBalanceBN() {
        const wallet = await this.wallet;
        const balance = await wallet.getBalanceBN();
        return balance;
    }
    /**
     *  Retrieve and decode the {@linkcode types.FunctionAccountData} stored in this account.
     */
    async loadData() {
        const data = await types.FunctionAccountData.fetch(this.program, this.publicKey);
        if (!data) {
            throw new errors.AccountNotFoundError("Function", this.publicKey);
        }
        this._wallet = Promise.resolve(new SwitchboardWallet(this.program, data.escrowWallet));
        return data;
    }
    /**
     *  Decode the {@linkcode types.FunctionAccountData} stored in this account.
     */
    static async decode(program, accountInfo) {
        if (!accountInfo.owner.equals(program.attestationProgramId)) {
            throw new errors.IncorrectOwner(program.attestationProgramId, accountInfo.owner);
        }
        const data = types.FunctionAccountData.decode(accountInfo.data);
        if (!data) {
            throw new errors.AccountNotFoundError("Function", PublicKey.default);
        }
        assert(data.creatorSeed.length === 32);
        const functionAccount = FunctionAccount.fromSeed(program, new Uint8Array(data.creatorSeed), data.createdAtSlot);
        functionAccount._wallet = Promise.resolve(new SwitchboardWallet(program, data.escrowWallet));
        return [functionAccount, data];
    }
    /**
     *  Load an existing {@linkcode FunctionAccount} with its current on-chain state
     */
    static async load(program, address) {
        const functionAccount = new FunctionAccount(program, address);
        const state = await functionAccount.loadData();
        return [functionAccount, state];
    }
    static async createInstruction(program, payer, params, wallet, options) {
        const authorityPubkey = params.authority ?? payer;
        const cronSchedule = params.schedule
            ? Buffer.from(parseCronSchedule(params.schedule), "utf-8")
            : Buffer.from(Array(64).fill(0));
        const attestationQueueAccount = params.attestationQueue;
        const recentSlot = params.recentSlot
            ? new BN(params.recentSlot)
            : new BN((await program.connection.getLatestBlockhashAndContext({
                commitment: "finalized",
            })).context.slot - 1);
        const creatorSeed = params.creatorSeed
            ? parseRawBuffer(params.creatorSeed, 32)
            : payer.toBytes();
        assert(creatorSeed.length === 32);
        const functionAccount = FunctionAccount.fromSeed(program, creatorSeed, recentSlot);
        const [addressLookupTable] = PublicKey.findProgramAddressSync([functionAccount.publicKey.toBuffer(), recentSlot.toBuffer("le", 8)], addressLookupProgram);
        let escrowWallet;
        let escrowWalletAuthority;
        if (wallet) {
            escrowWallet = wallet;
            escrowWalletAuthority = (await escrowWallet.loadData()).authority;
            if (!escrowWalletAuthority.equals(payer) &&
                !escrowWalletAuthority.equals(authorityPubkey)) {
                throw new errors.IncorrectAuthority(escrowWalletAuthority, authorityPubkey);
            }
        }
        else {
            escrowWallet = SwitchboardWallet.fromSeed(program, attestationQueueAccount.publicKey, authorityPubkey, functionAccount.publicKey.toBytes());
            escrowWalletAuthority = authorityPubkey;
        }
        const instruction = types.functionInit(program, {
            params: {
                name: new Uint8Array(Buffer.from(params.name ?? "", "utf8")),
                metadata: new Uint8Array(Buffer.from(params.metadata ?? "", "utf8")),
                container: new Uint8Array(Buffer.from(params.container, "utf8")),
                containerRegistry: new Uint8Array(Buffer.from(params.containerRegistry ?? "dockerhub", "utf8")),
                version: new Uint8Array(Buffer.from(params.version ?? "latest", "utf8")),
                schedule: new Uint8Array(cronSchedule),
                mrEnclave: Array.from(params.mrEnclave ? parseRawMrEnclave(params.mrEnclave) : []),
                recentSlot: recentSlot,
                requestsDisabled: params.requestsDisabled ?? false,
                requestsRequireAuthorization: params.requestsRequireAuthorization ?? false,
                requestsFee: numToBN(params.requestsFee),
                creatorSeed: Array.from(creatorSeed),
            },
        }, {
            function: functionAccount.publicKey,
            addressLookupTable: addressLookupTable,
            authority: authorityPubkey,
            attestationQueue: attestationQueueAccount.publicKey,
            payer,
            wallet: escrowWallet.publicKey,
            walletAuthority: escrowWalletAuthority,
            tokenWallet: escrowWallet.tokenWallet,
            mint: program.mint.address,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
            addressLookupProgram: addressLookupProgram,
        });
        functionAccount.wallet = Promise.resolve(escrowWallet);
        return [
            functionAccount,
            new TransactionObject(payer, [
                ComputeBudgetProgram.setComputeUnitLimit({ units: 250000 }),
                instruction,
            ], [], {
                ...options,
                computeUnitLimit: undefined,
            }),
        ];
    }
    static async create(program, params, wallet, options) {
        const [account, txnObject] = await this.createInstruction(program, program.walletPubkey, params, wallet, options);
        const txSignature = await program.signAndSend(txnObject, options);
        return [account, txSignature];
    }
    async createRequestInstruction(payer, params, options) {
        // const functionState = await this.loadData();
        const [requestAccount, txnObject] = await FunctionRequestAccount.createInstruction(this.program, payer, {
            ...params,
            functionAccount: this,
        }, options);
        return [requestAccount, txnObject];
    }
    async createRequest(params, options) {
        const [account, txnObject] = await this.createRequestInstruction(this.program.walletPubkey, params, options);
        const txSignature = await this.program.signAndSend(txnObject, options);
        return [account, txSignature];
    }
    async setConfigInstruction(payer, params, options) {
        const functionState = await this.loadData();
        if (params.authority) {
            if (!params.authority.publicKey.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, params.authority.publicKey);
            }
        }
        else {
            if (!payer.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, payer);
            }
        }
        const toOptionalBytes = (param) => {
            return param ? new Uint8Array(Buffer.from(param, "utf8")) : null;
        };
        const setConfigIxn = types.functionSetConfig(this.program, {
            params: {
                name: toOptionalBytes(params.name),
                metadata: toOptionalBytes(params.metadata),
                container: toOptionalBytes(params.container),
                containerRegistry: toOptionalBytes(params.containerRegistry),
                version: toOptionalBytes(params.version),
                schedule: toOptionalBytes(params.schedule),
                mrEnclaves: params.mrEnclaves
                    ? params.mrEnclaves.map((mrEnclave) => Array.from(parseRawBuffer(mrEnclave)))
                    : null,
                requestsDisabled: params.requestsDisabled ?? null,
                requestsRequireAuthorization: params.requestsRequireAuthorization ?? null,
                requestsFee: params.requestsFee ? new BN(params.requestsFee) : null,
            },
        }, {
            function: this.publicKey,
            authority: functionState.authority,
        });
        return new TransactionObject(payer, [setConfigIxn], params?.authority ? [params.authority] : [], options);
    }
    async setConfig(params, options) {
        return await this.setConfigInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    static hasMrEnclave(mrEnclaves, targetMrEnclave) {
        return containsMrEnclave(mrEnclaves, targetMrEnclave);
    }
    async addMrEnclaveInstruction(payer, mrEnclave, params, options) {
        const force = params?.force ?? false;
        const functionState = params?.functionState ?? (await this.loadData());
        if (FunctionAccount.hasMrEnclave(functionState.mrEnclaves, mrEnclave)) {
            throw new errors.FunctionMrEnclaveAlreadySet();
        }
        const filteredMrEnclaves = functionState.mrEnclaves.filter((arr) => !arr.every((num) => num === 0));
        if (filteredMrEnclaves.length >= 32 && !force) {
            throw new errors.FunctionMrEnclavesFull();
        }
        const newMrEnclaves = [
            ...(filteredMrEnclaves.length >= 32
                ? filteredMrEnclaves.slice(filteredMrEnclaves.length - 32 + 1)
                : filteredMrEnclaves),
            Array.from(mrEnclave),
        ];
        if (params?.authority) {
            if (!params.authority.publicKey.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, params.authority.publicKey);
            }
        }
        else {
            if (!payer.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, payer);
            }
        }
        const setConfigIxn = types.functionSetConfig(this.program, {
            params: {
                name: null,
                metadata: null,
                container: null,
                containerRegistry: null,
                version: null,
                schedule: null,
                mrEnclaves: newMrEnclaves,
                requestsDisabled: null,
                requestsRequireAuthorization: null,
                requestsFee: null,
            },
        }, {
            function: this.publicKey,
            authority: functionState.authority,
        });
        return new TransactionObject(payer, [setConfigIxn], params?.authority ? [params.authority] : [], options);
    }
    async addMrEnclave(mrEnclave, params, options) {
        return await this.addMrEnclaveInstruction(this.program.walletPubkey, mrEnclave, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    /**
     * Try to add a MrEnclave to the function config, if it is not already present. Returns undefined
     * if MrEnclave is already in the config.
     */
    async tryAddMrEnclave(mrEnclave, params, options) {
        const functionState = params?.functionState ?? (await this.loadData());
        if (FunctionAccount.hasMrEnclave(functionState.mrEnclaves, mrEnclave)) {
            return undefined;
        }
        return await this.addMrEnclaveInstruction(this.program.walletPubkey, mrEnclave, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async setEscrowInstruction(payer, params, options) {
        const signers = [];
        if (params.authority) {
            signers.push(params.authority);
        }
        if (params.newEscrowAuthority) {
            signers.push(params.newEscrowAuthority);
        }
        const functionState = await this.loadData();
        const currentWallet = await this.wallet;
        const currentWalletState = await currentWallet.loadData();
        const newWallet = params.newEscrow;
        const newWalletState = await newWallet.loadData();
        const functionSetEscrowIxn = types.functionSetEscrow(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            attestationQueue: functionState.attestationQueue,
            escrowWallet: currentWallet.publicKey,
            escrowAuthority: currentWalletState.authority,
            newEscrow: newWallet.publicKey,
            newEscrowAuthority: newWalletState.authority,
            newEscrowTokenWallet: newWallet.tokenWallet,
        });
        return new TransactionObject(payer, [functionSetEscrowIxn], signers, options);
    }
    async setEscrow(params, options) {
        return await this.setEscrowInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async setAuthorityInstruction(payer, params, options) {
        const signers = [];
        if (params.authority) {
            signers.push(params.authority);
        }
        if (params.walletAuthority) {
            signers.push(params.walletAuthority);
        }
        const functionState = await this.loadData();
        const wallet = await this.wallet;
        const walletState = await wallet.loadData();
        const functionSetAuthorityIxn = types.functionSetAuthority(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            attestationQueue: functionState.attestationQueue,
            escrowWallet: wallet.publicKey,
            escrowAuthority: walletState.authority,
            newAuthority: params.newAuthority,
            walletAuthority: params.walletAuthority
                ? params.walletAuthority.publicKey
                : SB_ATTESTATION_PID,
        });
        return new TransactionObject(payer, [handleOptionalPubkeys(functionSetAuthorityIxn)], signers, options);
    }
    async setAuthority(params, options) {
        return await this.setAuthorityInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async resetEscrowInstruction(payer, authority, options) {
        const functionState = await this.loadData();
        const defaultWallet = SwitchboardWallet.fromSeed(this.program, functionState.attestationQueue, functionState.authority, this.publicKey.toBytes());
        const ixn = types.functionResetEscrow(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            attestationQueue: functionState.attestationQueue,
            mint: this.program.mint.address,
            escrowWallet: functionState.escrowWallet,
            defaultWallet: defaultWallet.publicKey,
            tokenWallet: defaultWallet.tokenWallet,
            payer: payer,
            tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,
            associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,
            systemProgram: anchor.web3.SystemProgram.programId,
        });
        const txn = new TransactionObject(payer, [ixn], authority ? [authority] : [], options);
        return txn;
    }
    async resetEscrow(authority, options) {
        return await this.resetEscrowInstruction(this.program.walletPubkey, authority, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async fundInstruction(payer, params, options) {
        const wallet = await this.wallet;
        const txn = await wallet.fundInstruction(payer, params, options);
        return txn;
    }
    async fund(params, options) {
        return await this.fundInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async wrapInstruction(payer, amount, options) {
        const wallet = await this.wallet;
        const txn = await wallet.wrapInstruction(payer, amount, options);
        return txn;
    }
    async wrap(amount, options) {
        return await this.wrapInstruction(this.program.walletPubkey, amount, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async withdrawInstruction(payer, amount, destinationWallet, options) {
        const wallet = await this.wallet;
        const txn = await wallet.withdrawInstruction(payer, amount, destinationWallet, options);
        return txn;
    }
    async withdraw(amount, destinationWallet, options) {
        return await this.withdrawInstruction(this.program.walletPubkey, amount, destinationWallet, options).then((txn) => this.program.signAndSend(txn, options));
    }
    async closeAccountInstruction(payer, params, options) {
        const signers = [];
        if (params.authority) {
            signers.push(params.authority);
        }
        const functionState = await this.loadData();
        const wallet = await this.wallet;
        const functionCloseIxn = types.functionClose(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            addressLookupProgram: addressLookupProgram,
            addressLookupTable: functionState.addressLookupTable,
            escrowWallet: wallet.publicKey,
            solDest: payer,
            escrowDest: this.program.mint.getAssociatedAddress(payer),
            tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,
            systemProgram: anchor.web3.SystemProgram.programId,
        });
        return new TransactionObject(payer, [functionCloseIxn], signers, options);
    }
    async closeAccount(params, options) {
        return await this.closeAccountInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    verifyInstructionSync(params) {
        const wallet = new SwitchboardWallet(this.program, params.escrowWallet);
        const escrowTokenWallet = wallet.tokenWallet;
        return types.functionVerify(this.program, {
            params: {
                observedTime: params.observedTime,
                nextAllowedTimestamp: params.nextAllowedTimestamp,
                isFailure: params.isFailure,
                mrEnclave: Array.from(params.mrEnclave),
            },
        }, {
            // fn accounts
            function: this.publicKey,
            functionEnclaveSigner: params.functionEnclaveSigner,
            // verifier accounts
            verifier: params.quoteVerifier,
            verifierSigner: params.quoteVerifierEnclaveSigner,
            verifierPermission: AttestationPermissionAccount.fromSeed(this.program, params.attestationQueueAuthority, params.attestationQueue, params.quoteVerifier).publicKey,
            // token accounts
            escrowWallet: params.escrowWallet,
            escrowTokenWallet: escrowTokenWallet,
            receiver: params.receiver,
            // others
            attestationQueue: params.attestationQueue,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
        });
    }
    async verifyInstruction(params) {
        const functionState = params.fnState ?? (await this.loadData());
        const wallet = await this.wallet;
        let attestationQueueAuthority = params.attestationQueueAuthority;
        if (!attestationQueueAuthority) {
            const attestationQueueAccount = new AttestationQueueAccount(this.program, functionState.attestationQueue);
            attestationQueueAuthority = (await attestationQueueAccount.loadData())
                .authority;
        }
        const quoteVerifier = await params.verifier.loadData();
        return this.verifyInstructionSync({
            observedTime: params.observedTime,
            nextAllowedTimestamp: params.nextAllowedTimestamp,
            isFailure: params.isFailure,
            mrEnclave: params.mrEnclave,
            escrowWallet: wallet.publicKey,
            functionEnclaveSigner: params.functionEnclaveSigner,
            attestationQueue: functionState.attestationQueue,
            attestationQueueAuthority: attestationQueueAuthority,
            quoteVerifier: params.verifier.publicKey,
            quoteVerifierEnclaveSigner: quoteVerifier.enclave.enclaveSigner,
            receiver: params.receiver,
        });
    }
    async verifyTransaction(params) {
        const fnState = await this.loadData();
        const ixn = await this.verifyInstruction({ ...params, fnState });
        const lookupTable = await this.program.connection
            .getAddressLookupTable(fnState.addressLookupTable)
            .then((res) => res.value);
        const messageV0 = new anchor.web3.TransactionMessage({
            payerKey: this.program.walletPubkey,
            recentBlockhash: (await this.program.connection.getLatestBlockhash())
                .blockhash,
            instructions: [ixn], // note this is an array of instructions
        }).compileToV0Message([lookupTable]);
        const transactionV0 = new anchor.web3.VersionedTransaction(messageV0);
        return transactionV0;
    }
    async verify(params, options) {
        const transactionV0 = await this.verifyTransaction({
            ...params,
            verifierEnclaveSigner: params.verifierEnclaveSigner.publicKey,
            functionEnclaveSigner: params.functionEnclaveSigner.publicKey,
        });
        transactionV0.sign([params.verifierEnclaveSigner]);
        transactionV0.sign([params.functionEnclaveSigner]);
        transactionV0.sign([this.program.wallet.payer]);
        const txnSignature = await this.program.connection.sendEncodedTransaction(Buffer.from(transactionV0.serialize()).toString("base64"), options);
        return txnSignature;
    }
    async triggerInstruction(payer, params, options) {
        const functionState = await this.loadData();
        // verify authority is correct
        if (params && params?.authority) {
            if (!params.authority.publicKey.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, params.authority.publicKey);
            }
        }
        else {
            if (!payer.equals(functionState.authority)) {
                throw new errors.IncorrectAuthority(functionState.authority, payer);
            }
        }
        const functionTrigger = types.functionTrigger(this.program, { params: {} }, {
            function: this.publicKey,
            authority: functionState.authority,
            attestationQueue: functionState.attestationQueue,
        });
        return new TransactionObject(payer, [functionTrigger], params?.authority ? [params.authority] : [], options);
    }
    async trigger(params, options) {
        return await this.triggerInstruction(this.program.walletPubkey, params, options).then((txn) => this.program.signAndSend(txn, options));
    }
    static decodeAddressLookup(lookupTable) {
        const addresses = lookupTable.state.addresses;
        if (addresses.length < 16) {
            throw new Error(`Failed to decode address lookup table`);
        }
        const systemProgram = addresses[0];
        if (!systemProgram.equals(anchor.web3.SystemProgram.programId)) {
            throw new Error("AddressLookupMismatch");
        }
        const tokenProgram = addresses[1];
        if (!tokenProgram.equals(anchor.utils.token.TOKEN_PROGRAM_ID)) {
            throw new Error("AddressLookupMismatch");
        }
        const assocatedTokenProgram = addresses[2];
        if (!assocatedTokenProgram.equals(anchor.utils.token.ASSOCIATED_PROGRAM_ID)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarRent = addresses[3];
        if (!sysVarRent.equals(anchor.web3.SYSVAR_RENT_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarRecentBlockhashes = addresses[4];
        if (!sysVarRecentBlockhashes.equals(anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarInstructions = addresses[5];
        if (!sysVarInstructions.equals(anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarSlotHashes = addresses[6];
        if (!sysVarSlotHashes.equals(anchor.web3.SYSVAR_SLOT_HASHES_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const sysVarSlotHistory = addresses[7];
        if (!sysVarSlotHistory.equals(anchor.web3.SYSVAR_SLOT_HISTORY_PUBKEY)) {
            throw new Error("AddressLookupMismatch");
        }
        const switchboardProgram = addresses[8];
        if (!switchboardProgram.equals(SB_V2_PID)) {
            throw new Error("AddressLookupMismatch");
        }
        const attestationProgram = addresses[9];
        if (!attestationProgram.equals(SB_ATTESTATION_PID)) {
            throw new Error("AddressLookupMismatch");
        }
        // switchboard accounts, not worth the network calls
        const attestationQueuePubkey = addresses[10];
        const functionPubkey = addresses[11];
        const functionAuthorityPubkey = addresses[12];
        const mintPubkey = addresses[13];
        const walletPubkey = addresses[14];
        const escrowPubkey = addresses[15];
        return {
            systemProgram,
            tokenProgram,
            assocatedTokenProgram,
            sysVarRent,
            sysVarRecentBlockhashes,
            sysVarInstructions,
            sysVarSlotHashes,
            sysVarSlotHistory,
            switchboardProgram,
            attestationProgram,
            attestationQueuePubkey,
            functionPubkey,
            functionAuthorityPubkey,
            mintPubkey,
            walletPubkey,
            escrowPubkey, // 16
        };
    }
    static getVerificationStatus(state) {
        switch (state.enclave.verificationStatus) {
            case types.VerificationStatus.None.discriminator:
                return new types.VerificationStatus.None();
            case types.VerificationStatus.VerificationPending.discriminator:
                return new types.VerificationStatus.VerificationPending();
            case types.VerificationStatus.VerificationFailure.discriminator:
                return new types.VerificationStatus.VerificationFailure();
            case types.VerificationStatus.VerificationSuccess.discriminator:
                return new types.VerificationStatus.VerificationSuccess();
            case types.VerificationStatus.VerificationOverride.discriminator:
                return new types.VerificationStatus.VerificationOverride();
        }
        throw new Error(`Failed to get the verification status, expected [${types.VerificationStatus.None.discriminator}, ${types.VerificationStatus.VerificationPending.discriminator}, ${types.VerificationStatus.VerificationFailure.discriminator}, ${types.VerificationStatus.VerificationSuccess.discriminator}], or ${types.VerificationStatus.VerificationOverride.discriminator}], received ${state.enclave.verificationStatus}`);
    }
}
export { FunctionAccount };
