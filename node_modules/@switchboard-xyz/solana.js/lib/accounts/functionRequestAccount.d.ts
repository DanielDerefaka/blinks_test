/// <reference types="node" resolution-mode="require"/>
import { Account } from "../accounts/account.js";
import * as types from "../generated/attestation-program/index.js";
import type { SwitchboardProgram } from "../SwitchboardProgram.js";
import type { SendTransactionObjectOptions, TransactionObjectOptions } from "../TransactionObject.js";
import { TransactionObject } from "../TransactionObject.js";
import { FunctionAccount } from "./index.js";
import { Commitment, PublicKey, TransactionInstruction, TransactionSignature } from "@solana/web3.js";
import { Keypair } from "@solana/web3.js";
import type { RawBuffer } from "@switchboard-xyz/common";
import { BN } from "@switchboard-xyz/common";
/**
 *  Parameters for initializing a {@linkcode FunctionRequestAccount}
 */
export interface FunctionRequestAccountInitParams {
    functionAccount: FunctionAccount;
    maxContainerParamsLen?: number;
    containerParams?: Buffer;
    garbageCollectionSlot?: number;
    /**
     *  A keypair to be used to address this account.
     *
     *  @default Keypair.generate()
     */
    keypair?: Keypair;
    authority?: PublicKey;
    /**
     * An optional keypair to be used to sign the transaction if the function requires
     * authorization on request initialization.
     */
    functionAuthority?: Keypair;
}
/**
 *  Parameters for setting a {@linkcode FunctionRequestAccount} config
 */
export interface FunctionRequestSetConfigParams {
    containerParams: Buffer;
    appendContainerParams?: boolean;
    authority?: Keypair;
}
/**
 *  Parameters for triggering a {@linkcode FunctionRequestAccount} config
 */
export interface FunctionRequestTriggerParams {
    bounty?: number | BN;
    slotsUntilExpiration?: BN;
    validAfterSlot?: BN;
    authority?: Keypair;
}
export interface FunctionRequestVerifyParams {
    observedTime?: number;
    isFailure?: boolean;
    mrEnclave: RawBuffer;
    requestSlot: number | BN;
    containerParamsHash: RawBuffer;
    functionEnclaveSigner: PublicKey;
    function: PublicKey;
    functionEscrow: PublicKey;
    verifierQuote: PublicKey;
    verifierEnclaveSigner: PublicKey;
    verifierPermission: PublicKey;
    attestationQueue: PublicKey;
    receiver: PublicKey;
}
/**
 * Account type representing a Switchboard Function.
 *
 * Data: {@linkcode types.FunctionRequestAccountData}
 */
export declare class FunctionRequestAccount extends Account<types.FunctionRequestAccountData> {
    static accountName: string;
    /**
     * Get the size of an {@linkcode FunctionRequestAccount} on-chain.
     */
    readonly size: number;
    /**
     *  Retrieve and decode the {@linkcode types.FunctionRequestAccountData} stored in this account.
     */
    loadData(): Promise<types.FunctionRequestAccountData>;
    static load(program: SwitchboardProgram, address: PublicKey | string): Promise<[FunctionRequestAccount, types.FunctionRequestAccountData]>;
    static createInstruction(program: SwitchboardProgram, payer: PublicKey, params: FunctionRequestAccountInitParams, options?: TransactionObjectOptions): Promise<[FunctionRequestAccount, TransactionObject]>;
    static create(program: SwitchboardProgram, params: FunctionRequestAccountInitParams, options?: SendTransactionObjectOptions): Promise<[FunctionRequestAccount, TransactionSignature]>;
    getEscrow(): PublicKey;
    getBalance(): Promise<number>;
    getBalanceBN(): Promise<BN>;
    setConfigInstruction(payer: PublicKey, params: FunctionRequestSetConfigParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    setConfig(params: FunctionRequestSetConfigParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    triggerInstruction(payer: PublicKey, params?: FunctionRequestTriggerParams, options?: TransactionObjectOptions): Promise<TransactionObject>;
    trigger(params?: FunctionRequestTriggerParams, options?: SendTransactionObjectOptions): Promise<TransactionSignature>;
    verifyIxn(params: FunctionRequestVerifyParams): TransactionInstruction;
    /**
     * Poll a FunctionRequest Account and wait for the status to be set to 'RequestSuccess' or 'RequestFailure'
     * @param requestSlot
     * @param maxAttempts
     * @throws if the round is never closed before maxAttempts
     * @returns
     */
    poll(requestSlot?: number, maxAttempts?: number, commitment?: Commitment): Promise<types.FunctionRequestTriggerRound>;
}
//# sourceMappingURL=functionRequestAccount.d.ts.map