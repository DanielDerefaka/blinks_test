import { IxFromHex } from "./utils/instructions.js";
import { decodeString } from "./utils/string.js";
import type { IOracleJob } from "./protos.js";

import type { TransactionInstruction } from "@solana/web3.js";
import axios from "axios";
import bs58 from "bs58";

export class CrossbarClient {
  readonly crossbarUrl: string;
  readonly verbose: boolean;

  static default(verbose?: boolean) {
    return new CrossbarClient("https://crossbar.switchboard.xyz", verbose);
  }

  constructor(crossbarUrl: string, verbose?: boolean) {
    this.crossbarUrl = new URL(crossbarUrl).origin;
    this.verbose = !!verbose;
  }

  /**
   * GET /fetch/:feedHash
   * Fetch data from the crossbar using the provided feedHash
   * @param {string} feedHash - The hash of the feed to fetch data for
   * @returns {Promise<any>} - The data fetched from the crossbar
   */
  async fetch(feedHash: string): Promise<any> {
    try {
      return await axios
        .get(`${this.crossbarUrl}/fetch/${feedHash}`)
        .then((resp) => resp.data);
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;

      const response = err.response;
      if (!response) throw err;

      // If response is outside of the 200 range, log the status and throw an error.
      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(`Bad Crossbar fetch status: ${response.status}`);
    }
  }

  /**
   * POST /store
   * Store oracle jobs on the crossbar, associated with a queue address
   * @param {string} queueAddress - The address of the queue
   * @param {IOracleJob[]} jobs - The oracle jobs to store
   * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
   */
  async store(
    queueAddress: string,
    jobs: IOracleJob[]
  ): Promise<{ cid: string; feedHash: string; queueHex: string }> {
    try {
      // Try to decode the queueAddress to a Buffer so that we can send it in the expected format,
      // base58, to the Crossbar node.
      const queue = decodeString(queueAddress);
      if (!queue) throw new Error(`Unable to parse queue: ${queueAddress}`);

      return await axios
        .post(
          `${this.crossbarUrl}/store`,
          { queue: bs58.encode(queue), jobs },
          { headers: { "Content-Type": "application/json" } }
        )
        .then((resp) => resp.data);
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;

      const response = err.response;
      if (!response) throw err;

      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(`Bad Crossbar store response: ${response.status}`);
    }
  }

  /**
   * GET /updates/solana/:network/:feedpubkeys
   * Fetch updates for Solana network feeds from the crossbar
   * @param {string} network - The Solana network to fetch updates for
   * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
   * @param {number} [numSignatures] - The number of signatures to fetch (optional)
   * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
   */
  async fetchSolanaUpdates(
    network: string,
    feedpubkeys: string[],
    numSignatures?: number
  ): Promise<
    {
      success: boolean;
      pullIx: TransactionInstruction;
      responses: { oracle: string; result: number | null; errors: string }[];
      lookupTables: string[];
    }[]
  > {
    try {
      if (!network) throw new Error("Network is required");
      if (!feedpubkeys || feedpubkeys.length === 0)
        throw new Error("At least one feed is required");

      const feedsParam = feedpubkeys.join(",");
      const response = await axios
        .get(`${this.crossbarUrl}/updates/solana/${network}/${feedsParam}`, {
          params: { numSignatures },
        })
        .then((resp) => resp.data);

      // Convert pullIx from hex to TransactionInstruction using IxFromHex
      const updates = response.map((update: any) => ({
        ...update,
        pullIx: IxFromHex(update.pullIx),
      }));

      return updates;
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;

      const response = err.response;
      if (!response) throw err;

      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(
        `Bad Crossbar fetchSolanaUpdates response: ${response.status}`
      );
    }
  }

  /**
   * GET /simulate/solana/:network/:feedpubkeys
   * Simulate fetching Solana feed results from the crossbar
   * @param {string} network - The Solana network to simulate
   * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
   * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
   */
  async simulateSolanaFeeds(
    network: string,
    feedpubkeys: string[]
  ): Promise<{ feed: string; feedHash: string; results: number[] }[]> {
    try {
      if (!network) throw new Error("Network is required");
      if (!feedpubkeys || feedpubkeys.length === 0)
        throw new Error("At least one feed is required");

      const feedsParam = feedpubkeys.join(",");
      return await axios
        .get(`${this.crossbarUrl}/simulate/solana/${network}/${feedsParam}`)
        .then((resp) => resp.data);
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;

      const response = err.response;
      if (!response) throw err;

      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(
        `Bad Crossbar simulateSolanaFeeds response: ${response.status}`
      );
    }
  }

  /**
   * GET /simulate/:feedHashes
   * Simulate fetching feed results from the crossbar using feed hashes
   * @param {string[]} feedHashes - The hashes of the feeds to simulate
   * @returns {Promise<{ feedHash: string; results: number[] }[]>} - The simulated feed results
   */
  async simulateFeeds(
    feedHashes: string[]
  ): Promise<{ feedHash: string; results: number[] }[]> {
    try {
      if (!feedHashes || feedHashes.length === 0)
        throw new Error("At least one feed is required");

      const feedsParam = feedHashes.join(",");
      return await axios
        .get(`${this.crossbarUrl}/simulate/${feedsParam}`)
        .then((resp) => resp.data);
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;

      const response = err.response;
      if (!response) throw err;

      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(`Bad Crossbar simulateFeed response: ${response.status}`);
    }
  }
}
