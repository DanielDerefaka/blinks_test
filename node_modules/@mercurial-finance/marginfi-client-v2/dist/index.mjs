// src/client.ts
import { AnchorProvider, BorshAccountsCoder, Program, translateAddress as translateAddress3 } from "@project-serum/anchor";
import { bs58 } from "@project-serum/anchor/dist/cjs/utils/bytes";
import {
  Connection,
  Keypair,
  PublicKey as PublicKey4,
  Transaction as Transaction2,
  TransactionMessage,
  VersionedTransaction
} from "@solana/web3.js";

// src/types.ts
var BankVaultType = /* @__PURE__ */ ((BankVaultType2) => {
  BankVaultType2[BankVaultType2["LiquidityVault"] = 0] = "LiquidityVault";
  BankVaultType2[BankVaultType2["InsuranceVault"] = 1] = "InsuranceVault";
  BankVaultType2[BankVaultType2["FeeVault"] = 2] = "FeeVault";
  return BankVaultType2;
})(BankVaultType || {});
var AccountType = /* @__PURE__ */ ((AccountType2) => {
  AccountType2["MarginfiGroup"] = "marginfiGroup";
  AccountType2["MarginfiAccount"] = "marginfiAccount";
  return AccountType2;
})(AccountType || {});

// src/idl/marginfi-types.ts
var IDL = {
  version: "0.1.0",
  name: "marginfi",
  instructions: [
    {
      name: "marginfiGroupInitialize",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: true,
          isSigner: true
        },
        {
          name: "admin",
          isMut: true,
          isSigner: true
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "marginfiGroupConfigure",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: true,
          isSigner: false
        },
        {
          name: "admin",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "config",
          type: {
            defined: "GroupConfig"
          }
        }
      ]
    },
    {
      name: "lendingPoolAddBank",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "admin",
          isMut: true,
          isSigner: true
        },
        {
          name: "bankMint",
          isMut: false,
          isSigner: false
        },
        {
          name: "bank",
          isMut: true,
          isSigner: true
        },
        {
          name: "liquidityVaultAuthority",
          isMut: false,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault_auth"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "liquidityVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "insuranceVaultAuthority",
          isMut: false,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "insurance_vault_auth"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "insuranceVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "insurance_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "feeVaultAuthority",
          isMut: false,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "fee_vault_auth"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "feeVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "fee_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "bankConfig",
          type: {
            defined: "BankConfig"
          }
        }
      ]
    },
    {
      name: "lendingPoolConfigureBank",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "admin",
          isMut: false,
          isSigner: true
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "bankConfigOpt",
          type: {
            defined: "BankConfigOpt"
          }
        }
      ]
    },
    {
      name: "lendingPoolSetupEmissions",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "admin",
          isMut: true,
          isSigner: true
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        },
        {
          name: "emissionsMint",
          isMut: false,
          isSigner: false
        },
        {
          name: "emissionsAuth",
          isMut: false,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "emissions_auth_seed"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              },
              {
                kind: "account",
                type: "publicKey",
                account: "Mint",
                path: "emissions_mint"
              }
            ]
          }
        },
        {
          name: "emissionsTokenAccount",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "emissions_token_account_seed"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              },
              {
                kind: "account",
                type: "publicKey",
                account: "Mint",
                path: "emissions_mint"
              }
            ]
          }
        },
        {
          name: "emissionsFundingAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "flags",
          type: "u64"
        },
        {
          name: "rate",
          type: "u64"
        },
        {
          name: "totalEmissions",
          type: "u64"
        }
      ]
    },
    {
      name: "lendingPoolHandleBankruptcy",
      docs: ["Handle bad debt of a bankrupt marginfi account for a given bank."],
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "admin",
          isMut: false,
          isSigner: true
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        },
        {
          name: "marginfiAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "liquidityVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "insuranceVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "insurance_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "insuranceVaultAuthority",
          isMut: false,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "insurance_vault_auth"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "marginfiAccountInitialize",
      docs: ["Initialize a marginfi account for a given group"],
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "marginfiAccount",
          isMut: true,
          isSigner: true
        },
        {
          name: "authority",
          isMut: false,
          isSigner: true
        },
        {
          name: "feePayer",
          isMut: true,
          isSigner: true
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "lendingAccountDeposit",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "marginfiAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "signer",
          isMut: false,
          isSigner: true
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        },
        {
          name: "signerTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "bankLiquidityVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        }
      ]
    },
    {
      name: "lendingAccountRepay",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "marginfiAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "signer",
          isMut: false,
          isSigner: true
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        },
        {
          name: "signerTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "bankLiquidityVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "repayAll",
          type: {
            option: "bool"
          }
        }
      ]
    },
    {
      name: "lendingAccountWithdraw",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "marginfiAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "signer",
          isMut: false,
          isSigner: true
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        },
        {
          name: "destinationTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "bankLiquidityVaultAuthority",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault_auth"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "bankLiquidityVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "withdrawAll",
          type: {
            option: "bool"
          }
        }
      ]
    },
    {
      name: "lendingAccountBorrow",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "marginfiAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "signer",
          isMut: false,
          isSigner: true
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        },
        {
          name: "destinationTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "bankLiquidityVaultAuthority",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault_auth"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "bankLiquidityVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        }
      ]
    },
    {
      name: "lendingAccountWithdrawEmissions",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "marginfiAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "signer",
          isMut: false,
          isSigner: true
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        },
        {
          name: "emissionsMint",
          isMut: false,
          isSigner: false
        },
        {
          name: "emissionsAuth",
          isMut: false,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "emissions_auth_seed"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              },
              {
                kind: "account",
                type: "publicKey",
                account: "Mint",
                path: "emissions_mint"
              }
            ]
          }
        },
        {
          name: "emissionsVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "emissions_token_account_seed"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              },
              {
                kind: "account",
                type: "publicKey",
                account: "Mint",
                path: "emissions_mint"
              }
            ]
          }
        },
        {
          name: "destinationAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "lendingAccountLiquidate",
      docs: ["Liquidate a lending account balance of an unhealthy marginfi account"],
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "assetBank",
          isMut: true,
          isSigner: false
        },
        {
          name: "liabBank",
          isMut: true,
          isSigner: false
        },
        {
          name: "liquidatorMarginfiAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "signer",
          isMut: false,
          isSigner: true
        },
        {
          name: "liquidateeMarginfiAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "bankLiquidityVaultAuthority",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault_auth"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "liab_bank"
              }
            ]
          }
        },
        {
          name: "bankLiquidityVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "liab_bank"
              }
            ]
          }
        },
        {
          name: "bankInsuranceVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "insurance_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "liab_bank"
              }
            ]
          }
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "assetAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "lendingPoolAccrueBankInterest",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "lendingPoolCollectBankFees",
      accounts: [
        {
          name: "marginfiGroup",
          isMut: false,
          isSigner: false
        },
        {
          name: "bank",
          isMut: true,
          isSigner: false
        },
        {
          name: "liquidityVaultAuthority",
          isMut: false,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault_auth"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "liquidityVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "liquidity_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "insuranceVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "insurance_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "feeVault",
          isMut: true,
          isSigner: false,
          pda: {
            seeds: [
              {
                kind: "const",
                type: "string",
                value: "fee_vault"
              },
              {
                kind: "account",
                type: "publicKey",
                path: "bank"
              }
            ]
          }
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    }
  ],
  accounts: [
    {
      name: "marginfiAccount",
      type: {
        kind: "struct",
        fields: [
          {
            name: "group",
            type: "publicKey"
          },
          {
            name: "authority",
            type: "publicKey"
          },
          {
            name: "lendingAccount",
            type: {
              defined: "LendingAccount"
            }
          },
          {
            name: "padding",
            type: {
              array: ["u64", 64]
            }
          }
        ]
      }
    },
    {
      name: "marginfiGroup",
      type: {
        kind: "struct",
        fields: [
          {
            name: "admin",
            type: "publicKey"
          },
          {
            name: "padding0",
            type: {
              array: ["u128", 32]
            }
          },
          {
            name: "padding1",
            type: {
              array: ["u128", 32]
            }
          }
        ]
      }
    },
    {
      name: "bank",
      type: {
        kind: "struct",
        fields: [
          {
            name: "mint",
            type: "publicKey"
          },
          {
            name: "mintDecimals",
            type: "u8"
          },
          {
            name: "group",
            type: "publicKey"
          },
          {
            name: "ignore1",
            type: {
              array: ["u8", 7]
            }
          },
          {
            name: "assetShareValue",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "liabilityShareValue",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "liquidityVault",
            type: "publicKey"
          },
          {
            name: "liquidityVaultBump",
            type: "u8"
          },
          {
            name: "liquidityVaultAuthorityBump",
            type: "u8"
          },
          {
            name: "insuranceVault",
            type: "publicKey"
          },
          {
            name: "insuranceVaultBump",
            type: "u8"
          },
          {
            name: "insuranceVaultAuthorityBump",
            type: "u8"
          },
          {
            name: "ignore2",
            type: {
              array: ["u8", 4]
            }
          },
          {
            name: "collectedInsuranceFeesOutstanding",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "feeVault",
            type: "publicKey"
          },
          {
            name: "feeVaultBump",
            type: "u8"
          },
          {
            name: "feeVaultAuthorityBump",
            type: "u8"
          },
          {
            name: "ignore3",
            type: {
              array: ["u8", 6]
            }
          },
          {
            name: "collectedGroupFeesOutstanding",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "totalLiabilityShares",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "totalAssetShares",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "lastUpdate",
            type: "i64"
          },
          {
            name: "config",
            type: {
              defined: "BankConfig"
            }
          },
          {
            name: "emissionsFlags",
            docs: [
              "Emissions Config Flags",
              "",
              "- EMISSIONS_FLAG_BORROW_ACTIVE: 1",
              "- EMISSIONS_FLAG_LENDING_ACTIVE: 2",
              ""
            ],
            type: "u64"
          },
          {
            name: "emissionsRate",
            docs: [
              "Emissions APR.",
              "Number of emitted tokens (emissions_mint) per 1M tokens (bank mint) (native amount) per 1 YEAR."
            ],
            type: "u64"
          },
          {
            name: "emissionsRemaining",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "emissionsMint",
            type: "publicKey"
          },
          {
            name: "padding0",
            type: {
              array: ["u128", 28]
            }
          },
          {
            name: "padding1",
            type: {
              array: ["u128", 32]
            }
          }
        ]
      }
    }
  ],
  types: [
    {
      name: "GroupEventHeader",
      type: {
        kind: "struct",
        fields: [
          {
            name: "signer",
            type: {
              option: "publicKey"
            }
          },
          {
            name: "marginfiGroup",
            type: "publicKey"
          }
        ]
      }
    },
    {
      name: "AccountEventHeader",
      type: {
        kind: "struct",
        fields: [
          {
            name: "signer",
            type: {
              option: "publicKey"
            }
          },
          {
            name: "marginfiAccount",
            type: "publicKey"
          },
          {
            name: "marginfiAccountAuthority",
            type: "publicKey"
          },
          {
            name: "marginfiGroup",
            type: "publicKey"
          }
        ]
      }
    },
    {
      name: "LiquidationBalances",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidateeAssetBalance",
            type: "f64"
          },
          {
            name: "liquidateeLiabilityBalance",
            type: "f64"
          },
          {
            name: "liquidatorAssetBalance",
            type: "f64"
          },
          {
            name: "liquidatorLiabilityBalance",
            type: "f64"
          }
        ]
      }
    },
    {
      name: "LendingAccount",
      type: {
        kind: "struct",
        fields: [
          {
            name: "balances",
            type: {
              array: [
                {
                  defined: "Balance"
                },
                16
              ]
            }
          },
          {
            name: "padding",
            type: {
              array: ["u64", 8]
            }
          }
        ]
      }
    },
    {
      name: "Balance",
      type: {
        kind: "struct",
        fields: [
          {
            name: "active",
            type: "bool"
          },
          {
            name: "bankPk",
            type: "publicKey"
          },
          {
            name: "ignore",
            type: {
              array: ["u8", 7]
            }
          },
          {
            name: "assetShares",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "liabilityShares",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "emissionsOutstanding",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "lastUpdate",
            type: "u64"
          },
          {
            name: "padding",
            type: {
              array: ["u64", 1]
            }
          }
        ]
      }
    },
    {
      name: "GroupConfig",
      type: {
        kind: "struct",
        fields: [
          {
            name: "admin",
            type: {
              option: "publicKey"
            }
          }
        ]
      }
    },
    {
      name: "InterestRateConfig",
      type: {
        kind: "struct",
        fields: [
          {
            name: "optimalUtilizationRate",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "plateauInterestRate",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "maxInterestRate",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "insuranceFeeFixedApr",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "insuranceIrFee",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "protocolFixedFeeApr",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "protocolIrFee",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "padding",
            type: {
              array: ["u128", 8]
            }
          }
        ]
      }
    },
    {
      name: "InterestRateConfigOpt",
      type: {
        kind: "struct",
        fields: [
          {
            name: "optimalUtilizationRate",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "plateauInterestRate",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "maxInterestRate",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "insuranceFeeFixedApr",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "insuranceIrFee",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "protocolFixedFeeApr",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "protocolIrFee",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          }
        ]
      }
    },
    {
      name: "BankConfig",
      docs: ["TODO: Convert weights to (u64, u64) to avoid precision loss (maybe?)"],
      type: {
        kind: "struct",
        fields: [
          {
            name: "assetWeightInit",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "assetWeightMaint",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "liabilityWeightInit",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "liabilityWeightMaint",
            type: {
              defined: "WrappedI80F48"
            }
          },
          {
            name: "depositLimit",
            type: "u64"
          },
          {
            name: "interestRateConfig",
            type: {
              defined: "InterestRateConfig"
            }
          },
          {
            name: "operationalState",
            type: {
              defined: "BankOperationalState"
            }
          },
          {
            name: "oracleSetup",
            type: "u8"
          },
          {
            name: "oracleKeys",
            type: {
              array: ["publicKey", 5]
            }
          },
          {
            name: "ignore1",
            type: {
              array: ["u8", 6]
            }
          },
          {
            name: "borrowLimit",
            type: "u64"
          },
          {
            name: "riskTier",
            type: {
              defined: "RiskTier"
            }
          },
          {
            name: "padding",
            type: {
              array: ["u8", 55]
            }
          }
        ]
      }
    },
    {
      name: "WrappedI80F48",
      type: {
        kind: "struct",
        fields: [
          {
            name: "value",
            type: "i128"
          }
        ]
      }
    },
    {
      name: "BankConfigOpt",
      type: {
        kind: "struct",
        fields: [
          {
            name: "assetWeightInit",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "assetWeightMaint",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "liabilityWeightInit",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "liabilityWeightMaint",
            type: {
              option: {
                defined: "WrappedI80F48"
              }
            }
          },
          {
            name: "depositLimit",
            type: {
              option: "u64"
            }
          },
          {
            name: "borrowLimit",
            type: {
              option: "u64"
            }
          },
          {
            name: "operationalState",
            type: {
              option: {
                defined: "BankOperationalState"
              }
            }
          },
          {
            name: "oracle",
            type: {
              option: {
                defined: "OracleConfig"
              }
            }
          },
          {
            name: "interestRateConfig",
            type: {
              option: {
                defined: "InterestRateConfigOpt"
              }
            }
          },
          {
            name: "riskTier",
            type: {
              option: {
                defined: "RiskTier"
              }
            }
          }
        ]
      }
    },
    {
      name: "OracleConfig",
      type: {
        kind: "struct",
        fields: [
          {
            name: "setup",
            type: {
              defined: "OracleSetup"
            }
          },
          {
            name: "keys",
            type: {
              array: ["publicKey", 5]
            }
          }
        ]
      }
    },
    {
      name: "BalanceIncreaseType",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Any"
          },
          {
            name: "RepayOnly"
          },
          {
            name: "DepositOnly"
          }
        ]
      }
    },
    {
      name: "BalanceDecreaseType",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Any"
          },
          {
            name: "WithdrawOnly"
          },
          {
            name: "BorrowOnly"
          },
          {
            name: "BypassBorrowLimit"
          }
        ]
      }
    },
    {
      name: "WeightType",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Initial"
          },
          {
            name: "Maintenance"
          }
        ]
      }
    },
    {
      name: "BalanceSide",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Assets"
          },
          {
            name: "Liabilities"
          }
        ]
      }
    },
    {
      name: "RiskRequirementType",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Initial"
          },
          {
            name: "Maintenance"
          }
        ]
      }
    },
    {
      name: "BankOperationalState",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Paused"
          },
          {
            name: "Operational"
          },
          {
            name: "ReduceOnly"
          }
        ]
      }
    },
    {
      name: "RiskTier",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Collateral"
          },
          {
            name: "Isolated"
          }
        ]
      }
    },
    {
      name: "BankVaultType",
      type: {
        kind: "enum",
        variants: [
          {
            name: "Liquidity"
          },
          {
            name: "Insurance"
          },
          {
            name: "Fee"
          }
        ]
      }
    },
    {
      name: "OracleSetup",
      type: {
        kind: "enum",
        variants: [
          {
            name: "None"
          },
          {
            name: "PythEma"
          },
          {
            name: "SwitchboardV2"
          }
        ]
      }
    }
  ],
  events: [
    {
      name: "MarginfiGroupCreateEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "GroupEventHeader"
          },
          index: false
        }
      ]
    },
    {
      name: "MarginfiGroupConfigureEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "GroupEventHeader"
          },
          index: false
        },
        {
          name: "config",
          type: {
            defined: "GroupConfig"
          },
          index: false
        }
      ]
    },
    {
      name: "LendingPoolBankCreateEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "GroupEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "LendingPoolBankConfigureEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "GroupEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "config",
          type: {
            defined: "BankConfigOpt"
          },
          index: false
        }
      ]
    },
    {
      name: "LendingPoolBankAccrueInterestEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "GroupEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "delta",
          type: "u64",
          index: false
        },
        {
          name: "feesCollected",
          type: "f64",
          index: false
        },
        {
          name: "insuranceCollected",
          type: "f64",
          index: false
        }
      ]
    },
    {
      name: "LendingPoolBankCollectFeesEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "GroupEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "groupFeesCollected",
          type: "f64",
          index: false
        },
        {
          name: "groupFeesOutstanding",
          type: "f64",
          index: false
        },
        {
          name: "insuranceFeesCollected",
          type: "f64",
          index: false
        },
        {
          name: "insuranceFeesOutstanding",
          type: "f64",
          index: false
        }
      ]
    },
    {
      name: "LendingPoolBankHandleBankruptcyEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "AccountEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "badDebt",
          type: "f64",
          index: false
        },
        {
          name: "coveredAmount",
          type: "f64",
          index: false
        },
        {
          name: "socializedAmount",
          type: "f64",
          index: false
        }
      ]
    },
    {
      name: "MarginfiAccountCreateEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "AccountEventHeader"
          },
          index: false
        }
      ]
    },
    {
      name: "LendingAccountDepositEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "AccountEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "amount",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "LendingAccountRepayEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "AccountEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "amount",
          type: "u64",
          index: false
        },
        {
          name: "closeBalance",
          type: "bool",
          index: false
        }
      ]
    },
    {
      name: "LendingAccountBorrowEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "AccountEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "amount",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "LendingAccountWithdrawEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "AccountEventHeader"
          },
          index: false
        },
        {
          name: "bank",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "amount",
          type: "u64",
          index: false
        },
        {
          name: "closeBalance",
          type: "bool",
          index: false
        }
      ]
    },
    {
      name: "LendingAccountLiquidateEvent",
      fields: [
        {
          name: "header",
          type: {
            defined: "AccountEventHeader"
          },
          index: false
        },
        {
          name: "liquidateeMarginfiAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "liquidateeMarginfiAccountAuthority",
          type: "publicKey",
          index: false
        },
        {
          name: "assetBank",
          type: "publicKey",
          index: false
        },
        {
          name: "assetMint",
          type: "publicKey",
          index: false
        },
        {
          name: "liabilityBank",
          type: "publicKey",
          index: false
        },
        {
          name: "liabilityMint",
          type: "publicKey",
          index: false
        },
        {
          name: "liquidateePreHealth",
          type: "f64",
          index: false
        },
        {
          name: "liquidateePostHealth",
          type: "f64",
          index: false
        },
        {
          name: "preBalances",
          type: {
            defined: "LiquidationBalances"
          },
          index: false
        },
        {
          name: "postBalances",
          type: {
            defined: "LiquidationBalances"
          },
          index: false
        }
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "MathError",
      msg: "Math error"
    },
    {
      code: 6001,
      name: "BankNotFound",
      msg: "Invalid bank index"
    },
    {
      code: 6002,
      name: "LendingAccountBalanceNotFound",
      msg: "Lending account balance not found"
    },
    {
      code: 6003,
      name: "BankAssetCapacityExceeded",
      msg: "Bank deposit capacity exceeded"
    },
    {
      code: 6004,
      name: "InvalidTransfer",
      msg: "Invalid transfer"
    },
    {
      code: 6005,
      name: "MissingPythOrBankAccount",
      msg: "Missing Pyth or Bank account"
    },
    {
      code: 6006,
      name: "MissingPythAccount",
      msg: "Missing Pyth account"
    },
    {
      code: 6007,
      name: "InvalidOracleAccount",
      msg: "Invalid Pyth account"
    },
    {
      code: 6008,
      name: "MissingBankAccount",
      msg: "Missing Bank account"
    },
    {
      code: 6009,
      name: "InvalidBankAccount",
      msg: "Invalid Bank account"
    },
    {
      code: 6010,
      name: "BadAccountHealth",
      msg: "Bad account health"
    },
    {
      code: 6011,
      name: "LendingAccountBalanceSlotsFull",
      msg: "Lending account balance slots are full"
    },
    {
      code: 6012,
      name: "BankAlreadyExists",
      msg: "Bank already exists"
    },
    {
      code: 6013,
      name: "IllegalLiquidation",
      msg: "Illegal post liquidation state, account is either not unhealthy or liquidation was too big"
    },
    {
      code: 6014,
      name: "AccountNotBankrupt",
      msg: "Account is not bankrupt"
    },
    {
      code: 6015,
      name: "BalanceNotBadDebt",
      msg: "Account balance is not bad debt"
    },
    {
      code: 6016,
      name: "InvalidConfig",
      msg: "Invalid group config"
    },
    {
      code: 6017,
      name: "StaleOracle",
      msg: "Stale oracle data"
    },
    {
      code: 6018,
      name: "BankPaused",
      msg: "Bank paused"
    },
    {
      code: 6019,
      name: "BankReduceOnly",
      msg: "Bank is ReduceOnly mode"
    },
    {
      code: 6020,
      name: "BankAccoutNotFound",
      msg: "Bank is missing"
    },
    {
      code: 6021,
      name: "OperationDepositOnly",
      msg: "Operation is deposit-only"
    },
    {
      code: 6022,
      name: "OperationWithdrawOnly",
      msg: "Operation is withdraw-only"
    },
    {
      code: 6023,
      name: "OperationBorrowOnly",
      msg: "Operation is borrow-only"
    },
    {
      code: 6024,
      name: "OperationRepayOnly",
      msg: "Operation is repay-only"
    },
    {
      code: 6025,
      name: "NoAssetFound",
      msg: "No asset found"
    },
    {
      code: 6026,
      name: "NoLiabilityFound",
      msg: "No liability found"
    },
    {
      code: 6027,
      name: "InvalidOracleSetup",
      msg: "Invalid oracle setup"
    },
    {
      code: 6028,
      name: "IllegalUtilizationRatio",
      msg: "Invalid bank utilization ratio"
    },
    {
      code: 6029,
      name: "BankLiabilityCapacityExceeded",
      msg: "Bank borrow cap exceeded"
    },
    {
      code: 6030,
      name: "InvalidPrice",
      msg: "Invalid Price"
    },
    {
      code: 6031,
      name: "IsolatedAccountIllegalState",
      msg: "Account can have only one liablity when account is under isolated risk"
    },
    {
      code: 6032,
      name: "EmissionsAlreadySetup",
      msg: "Emissions already setup"
    },
    {
      code: 6033,
      name: "OracleNotSetup",
      msg: "Oracle is not set"
    },
    {
      code: 6034,
      name: "InvalidSwitchboardDecimalConversion",
      msg: "Invalid swithcboard decimal conversion"
    }
  ]
};

// src/config.ts
import { PublicKey } from "@solana/web3.js";
import { array, assert, enums, object, string } from "superstruct";

// src/configs.json
var configs_default = [
  {
    label: "production",
    cluster: "mainnet",
    program: "MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA",
    group: "4qp6Fx6tnZkY5Wropq9wUYgtFxXKwE6viZxFHg3rdAG8",
    banks: [
      {
        label: "USDC",
        address: "2s37akK2eyBbp8DZgCm7RtsaEz8eJP3Nxd4urLHQv7yB"
      },
      {
        label: "SOL",
        address: "CCKtUs6Cgwo4aaQUmBPmyoApH2gUDErxNZCAntD6LYGh"
      },
      {
        label: "mSOL",
        address: "22DcjMZrMwC5Bpa5AGBsmjc5V9VuQrXG6N9ZtdUNyYGE"
      },
      {
        label: "BONK",
        address: "DeyH7QxWvnbbaVB4zFrf4hoq7Q8z1ZT14co42BGwGtfM"
      },
      {
        label: "USDT",
        address: "HmpMfL8942u22htC4EMiWgLX931g3sacXFR6KjuLgKLV"
      },
      {
        label: "ETH",
        address: "BkUyfXjbBBALcfZvw76WAFRvYQ21xxMWWeoPtJrUqG3z"
      },
      {
        label: "WBTC",
        address: "BKsfDJCMbYep6gr9pq8PsmJbb5XGLHbAJzUV8vmorz7a"
      },
      {
        label: "JitoSOL",
        address: "Bohoc1ikHLD7xKJuzTyiTyCwzaL5N7ggJQu75A8mKYM8"
      },
      {
        label: "UXD",
        address: "BeNBJrAh1tZg5sqgt8D6AWKJLD5KkBrfZvtcgd7EuiAR"
      }
    ]
  },
  {
    label: "alpha",
    cluster: "mainnet",
    program: "yyyxaNHJP5FiDhmQW8RkBkp1jTL2cyxJmhMdWpJfsiy",
    group: "7xNRPf4qqgDAkvDEgkRuC4SevR1RUxzosoRb7GsaVsqa",
    banks: [
      {
        label: "USDC",
        address: "Hp5niMGdiSCUmEUJpNyF3n4NMthwwLVTAPZB1hyvVZd9"
      },
      {
        label: "SOL",
        address: "DDxthf5NdQe3VrKByCe41NjsU6tVmVsVBdCAtz143Hdp"
      }
    ]
  },
  {
    label: "mainnet-test-1",
    cluster: "mainnet",
    program: "MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA",
    group: "CWqJj49NPUGE7Y18QuKcJCC6vEyspCj91oKgECyfxepR",
    banks: [
      {
        label: "USDC",
        address: "4SryZ4bWGqEsNjbqNUKuxnoyagWgbxj6MavyUF2HRzhA"
      },
      {
        label: "SOL",
        address: "BpmLoZcyKJP9Jncq5TE7TTzxPV6PSbKNZkuvU1MB6t8e"
      }
    ]
  },
  {
    label: "staging",
    cluster: "mainnet",
    program: "MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA",
    group: "4qp6Fx6tnZkY5Wropq9wUYgtFxXKwE6viZxFHg3rdAG8",
    banks: [
      {
        label: "USDC",
        address: "2s37akK2eyBbp8DZgCm7RtsaEz8eJP3Nxd4urLHQv7yB"
      },
      {
        label: "SOL",
        address: "CCKtUs6Cgwo4aaQUmBPmyoApH2gUDErxNZCAntD6LYGh"
      }
    ]
  },
  {
    label: "dev.1",
    cluster: "devnet",
    program: "neetcne3Ctrrud7vLdt2ypMm21gZHGN2mCmqWaMVcBQ",
    group: "2eophx2kdM71vgKQnZXmA7GGCVZ1voRMxU2F4Gcournb",
    banks: [
      {
        label: "USDC",
        address: "Ervy8u3zyS6KZj5CfVRkiL1iykZeChDELZekAq7z9rNk"
      },
      {
        label: "SOL",
        address: "CmHpj7pTmEDg2hCDgTWP7Hcc4zG7nrGRrdjChgz6iM2K"
      }
    ]
  },
  {
    label: "dev",
    cluster: "devnet",
    program: "A7vUDErNPCTt9qrB6SSM4F6GkxzUe9d8P3cXSmRg4eY4",
    group: "52NC7T3NTPFFwoxJDFk9mbKcA7675DJ39H1iPNz5RjSV",
    banks: [
      {
        label: "USDC",
        address: "GhV6ZftLXv3o38CHMhX6nu8GkxS3kvrHSSCVpGFTysUC"
      },
      {
        label: "SOL",
        address: "2KvZHa7nPDBwLRz2yasXDnHsbyhrpzWkqEp6mEAnGeLJ"
      }
    ]
  }
];

// src/config.ts
var BankConfigRaw = object({
  label: string(),
  address: string()
});
var MarginfiConfigRaw = object({
  label: enums(["production", "alpha", "staging", "dev", "mainnet-test-1", "dev.1"]),
  cluster: string(),
  program: string(),
  group: string(),
  banks: array(BankConfigRaw)
});
var ConfigRaw = array(MarginfiConfigRaw);
function parseBankConfig(bankConfigRaw) {
  return {
    label: bankConfigRaw.label,
    address: new PublicKey(bankConfigRaw.address)
  };
}
function parseConfig(configRaw) {
  return {
    environment: configRaw.label,
    cluster: configRaw.cluster,
    programId: new PublicKey(configRaw.program),
    groupPk: new PublicKey(configRaw.group),
    banks: configRaw.banks.map((raw) => parseBankConfig(raw))
  };
}
function parseConfigs(configRaw) {
  return configRaw.reduce(
    (config, current, _) => ({
      [current.label]: parseConfig(current),
      ...config
    }),
    {}
  );
}
function loadDefaultConfig() {
  assert(configs_default, ConfigRaw);
  return parseConfigs(configs_default);
}
function getMarginfiConfig(environment, overrides) {
  const defaultConfigs = loadDefaultConfig();
  switch (environment) {
    case "production":
    case "alpha":
    case "staging":
    case "dev":
    case "mainnet-test-1":
    case "dev.1":
      const defaultConfig = defaultConfigs[environment];
      return {
        environment,
        programId: overrides?.programId || defaultConfig.programId,
        groupPk: overrides?.groupPk || defaultConfig.groupPk,
        cluster: overrides?.cluster || defaultConfig.cluster,
        banks: overrides?.banks || defaultConfig.banks
      };
    default:
      throw Error(`Unknown environment ${environment}`);
  }
}
function getConfig(environment = "production", overrides) {
  return {
    ...getMarginfiConfig(environment, overrides)
  };
}

// src/group.ts
import { BorshCoder as BorshCoder2, translateAddress as translateAddress2 } from "@project-serum/anchor";

// src/bank.ts
import BigNumber3 from "bignumber.js";

// src/account.ts
import {
  aprToApy,
  createAssociatedTokenAccountIdempotentInstruction,
  createCloseAccountInstruction,
  createSyncNativeInstruction,
  DEFAULT_COMMITMENT,
  NATIVE_MINT,
  nativeToUi,
  shortenAddress,
  uiToNative,
  wrappedI80F48toBigNumber
} from "@mrgnlabs/mrgn-common";
import { BN, BorshCoder, translateAddress } from "@project-serum/anchor";
import { associatedAddress } from "@project-serum/anchor/dist/cjs/utils/token";
import {
  ComputeBudgetProgram,
  PublicKey as PublicKey3,
  SystemProgram as SystemProgram2,
  Transaction
} from "@solana/web3.js";
import BigNumber from "bignumber.js";

// src/instructions.ts
import { SystemProgram } from "@solana/web3.js";
async function makeInitMarginfiAccountIx(mfProgram, accounts) {
  return mfProgram.methods.marginfiAccountInitialize().accounts({
    marginfiGroup: accounts.marginfiGroupPk,
    marginfiAccount: accounts.marginfiAccountPk,
    authority: accounts.authorityPk,
    systemProgram: SystemProgram.programId,
    feePayer: accounts.feePayerPk
  }).instruction();
}
async function makeDepositIx(mfProgram, accounts, args, remainingAccounts = []) {
  return mfProgram.methods.lendingAccountDeposit(args.amount).accounts({
    marginfiGroup: accounts.marginfiGroupPk,
    marginfiAccount: accounts.marginfiAccountPk,
    signer: accounts.authorityPk,
    signerTokenAccount: accounts.signerTokenAccountPk,
    bank: accounts.bankPk
  }).remainingAccounts(remainingAccounts).instruction();
}
async function makeRepayIx(mfProgram, accounts, args, remainingAccounts = []) {
  return mfProgram.methods.lendingAccountRepay(args.amount, args.repayAll ?? null).accounts({
    marginfiGroup: accounts.marginfiGroupPk,
    marginfiAccount: accounts.marginfiAccountPk,
    signer: accounts.authorityPk,
    signerTokenAccount: accounts.signerTokenAccountPk,
    bank: accounts.bankPk
  }).remainingAccounts(remainingAccounts).instruction();
}
async function makeWithdrawIx(mfProgram, accounts, args, remainingAccounts = []) {
  return mfProgram.methods.lendingAccountWithdraw(args.amount, args.withdrawAll ?? null).accounts({
    marginfiGroup: accounts.marginfiGroupPk,
    marginfiAccount: accounts.marginfiAccountPk,
    signer: accounts.signerPk,
    destinationTokenAccount: accounts.destinationTokenAccountPk,
    bank: accounts.bankPk
  }).remainingAccounts(remainingAccounts).instruction();
}
async function makeBorrowIx(mfProgram, accounts, args, remainingAccounts = []) {
  return mfProgram.methods.lendingAccountBorrow(args.amount).accounts({
    marginfiGroup: accounts.marginfiGroupPk,
    marginfiAccount: accounts.marginfiAccountPk,
    signer: accounts.signerPk,
    destinationTokenAccount: accounts.destinationTokenAccountPk,
    bank: accounts.bankPk
  }).remainingAccounts(remainingAccounts).instruction();
}
function makeLendingAccountLiquidateIx(mfiProgram, accounts, args, remainingAccounts = []) {
  return mfiProgram.methods.lendingAccountLiquidate(args.assetAmount).accounts({
    marginfiGroup: accounts.marginfiGroup,
    signer: accounts.signer,
    assetBank: accounts.assetBank,
    liabBank: accounts.liabBank,
    liquidatorMarginfiAccount: accounts.liquidatorMarginfiAccount,
    liquidateeMarginfiAccount: accounts.liquidateeMarginfiAccount
  }).remainingAccounts(remainingAccounts).instruction();
}
function makelendingAccountWithdrawEmissionIx(mfiProgram, accounts) {
  return mfiProgram.methods.lendingAccountWithdrawEmissions().accounts({
    marginfiGroup: accounts.marginfiGroup,
    marginfiAccount: accounts.marginfiAccount,
    signer: accounts.signer,
    destinationAccount: accounts.destinationTokenAccount,
    bank: accounts.bank,
    emissionsMint: accounts.emissionsMint
  }).instruction();
}
var instructions = {
  makeDepositIx,
  makeRepayIx,
  makeWithdrawIx,
  makeBorrowIx,
  makeInitMarginfiAccountIx,
  makeLendingAccountLiquidateIx,
  makelendingAccountWithdrawEmissionIx
};
var instructions_default = instructions;

// src/account.ts
var MarginfiAccount = class {
  /**
   * @internal
   */
  constructor(marginfiAccountPk, client, group, rawData) {
    this.client = client;
    this.publicKey = marginfiAccountPk;
    this._group = group;
    this._authority = rawData.authority;
    this._lendingBalances = rawData.lendingAccount.balances.map((la) => new Balance(la));
  }
  // --- Getters / Setters
  /**
   * Marginfi account authority address
   */
  get authority() {
    return this._authority;
  }
  /**
   * Marginfi group address
   */
  get group() {
    return this._group;
  }
  /**
   * Marginfi group address
   */
  get activeBalances() {
    return this._lendingBalances.filter((la) => la.active);
  }
  /** @internal */
  get _program() {
    return this.client.program;
  }
  /** @internal */
  get _config() {
    return this.client.config;
  }
  // --- Factories
  /**
   * MarginfiAccount network factory
   *
   * Fetch account data according to the config and instantiate the corresponding MarginfiAccount.
   *
   * @param marginfiAccountPk Address of the target account
   * @param client marginfi client
   * @param commitment Commitment level override
   * @returns MarginfiAccount instance
   */
  static async fetch(marginfiAccountPk, client, commitment) {
    const { config, program } = client;
    const _marginfiAccountPk = translateAddress(marginfiAccountPk);
    const accountData = await MarginfiAccount._fetchAccountData(_marginfiAccountPk, config, program, commitment);
    const marginfiAccount = new MarginfiAccount(
      _marginfiAccountPk,
      client,
      await group_default.fetch(config, program, commitment),
      accountData
    );
    return marginfiAccount;
  }
  /**
   * MarginfiAccount local factory (decoded)
   *
   * Instantiate a MarginfiAccount according to the provided decoded data.
   * Check sanity against provided config.
   *
   * @param marginfiAccountPk Address of the target account
   * @param client marginfi client
   * @param accountData Decoded marginfi marginfi account data
   * @param marginfiGroup MarginfiGroup instance
   * @returns MarginfiAccount instance
   */
  static fromAccountData(marginfiAccountPk, client, accountData, marginfiGroup) {
    if (!accountData.group.equals(client.config.groupPk))
      throw Error(
        `Marginfi account tied to group ${accountData.group.toBase58()}. Expected: ${client.config.groupPk.toBase58()}`
      );
    const _marginfiAccountPk = translateAddress(marginfiAccountPk);
    return new MarginfiAccount(_marginfiAccountPk, client, marginfiGroup, accountData);
  }
  /**
   * MarginfiAccount local factory (encoded)
   *
   * Instantiate a MarginfiAccount according to the provided encoded data.
   * Check sanity against provided config.
   *
   * @param marginfiAccountPk Address of the target account
   * @param client marginfi client
   * @param marginfiAccountRawData Encoded marginfi marginfi account data
   * @param marginfiGroup MarginfiGroup instance
   * @returns MarginfiAccount instance
   */
  static fromAccountDataRaw(marginfiAccountPk, client, marginfiAccountRawData, marginfiGroup) {
    const marginfiAccountData = MarginfiAccount.decode(marginfiAccountRawData);
    return MarginfiAccount.fromAccountData(marginfiAccountPk, client, marginfiAccountData, marginfiGroup);
  }
  /**
   * Create transaction instruction to deposit collateral into the marginfi account.
   *
   * @param amount Amount to deposit (UI unit)
   * @param bank Bank to deposit to
   * @returns `MarginDepositCollateral` transaction instruction
   */
  async makeDepositIx(amount, bank) {
    const userTokenAtaPk = await associatedAddress({
      mint: bank.mint,
      owner: this.client.provider.wallet.publicKey
    });
    const remainingAccounts = this.getHealthCheckAccounts([bank]);
    const ix = await instructions_default.makeDepositIx(
      this._program,
      {
        marginfiGroupPk: this.group.publicKey,
        marginfiAccountPk: this.publicKey,
        authorityPk: this.client.provider.wallet.publicKey,
        signerTokenAccountPk: userTokenAtaPk,
        bankPk: bank.publicKey
      },
      { amount: uiToNative(amount, bank.mintDecimals) },
      remainingAccounts
    );
    return {
      instructions: bank.mint.equals(NATIVE_MINT) ? await this.wrapInstructionForWSol(ix, amount) : [ix],
      keys: []
    };
  }
  /**
   * Deposit collateral into the marginfi account.
   *
   * @param amount Amount to deposit (UI unit)
   * @param bank Bank to deposit to
   * @returns Transaction signature
   */
  async deposit(amount, bank) {
    const ixs = await this.makeDepositIx(amount, bank);
    const tx = new Transaction().add(...ixs.instructions);
    const sig = await this.client.processTransaction(tx, []);
    await this.reload();
    return sig;
  }
  /**
   * Create transaction instruction to deposit collateral into the marginfi account.
   *
   * @param amount Amount to deposit (UI unit)
   * @param bank Bank to deposit to
   * @param repayAll (optional) Repay all the liability
   * @returns `LendingPool` transaction instruction
   */
  async makeRepayIx(amount, bank, repayAll = false) {
    const userTokenAtaPk = await associatedAddress({
      mint: bank.mint,
      owner: this.client.provider.wallet.publicKey
    });
    const remainingAccounts = repayAll ? this.getHealthCheckAccounts([], [bank]) : this.getHealthCheckAccounts([bank], []);
    const ix = await instructions_default.makeRepayIx(
      this._program,
      {
        marginfiGroupPk: this.group.publicKey,
        marginfiAccountPk: this.publicKey,
        authorityPk: this.client.provider.wallet.publicKey,
        signerTokenAccountPk: userTokenAtaPk,
        bankPk: bank.publicKey
      },
      { amount: uiToNative(amount, bank.mintDecimals), repayAll },
      remainingAccounts
    );
    return {
      instructions: bank.mint.equals(NATIVE_MINT) ? await this.wrapInstructionForWSol(ix, amount) : [ix],
      keys: []
    };
  }
  /**
   * Deposit collateral into the marginfi account.
   *
   * @param amount Amount to deposit (UI unit)
   * @param bank Bank to deposit to
   * @param repayAll (optional) Repay all the liability
   * @returns Transaction signature
   */
  async repay(amount, bank, repayAll = false) {
    const ixs = await this.makeRepayIx(amount, bank, repayAll);
    const tx = new Transaction();
    if (repayAll && !bank.emissionsMint.equals(PublicKey3.default)) {
      const userAta = await associatedAddress({
        mint: bank.emissionsMint,
        owner: this.client.provider.wallet.publicKey
      });
      const createAtaIdempotentIx = createAssociatedTokenAccountIdempotentInstruction(
        this.client.provider.wallet.publicKey,
        userAta,
        this.client.provider.wallet.publicKey,
        bank.emissionsMint
      );
      tx.add(createAtaIdempotentIx);
      tx.add(...(await this.makeWithdrawEmissionsIx(bank)).instructions);
    }
    tx.add(...ixs.instructions);
    const sig = await this.client.processTransaction(tx);
    await this.reload();
    return sig;
  }
  /**
   * Create transaction instruction to withdraw collateral from the marginfi account.
   *
   * @param amount Amount to withdraw (mint native unit)
   * @param bank Bank to withdraw from
   * @param withdrawAll (optional) Withdraw all the asset
   * @returns `MarginWithdrawCollateral` transaction instruction
   */
  async makeWithdrawIx(amount, bank, withdrawAll = false) {
    const userTokenAtaPk = await associatedAddress({
      mint: bank.mint,
      owner: this.client.provider.wallet.publicKey
    });
    const remainingAccounts = withdrawAll ? this.getHealthCheckAccounts([], [bank]) : this.getHealthCheckAccounts([bank], []);
    const ix = await instructions_default.makeWithdrawIx(
      this._program,
      {
        marginfiGroupPk: this.group.publicKey,
        marginfiAccountPk: this.publicKey,
        signerPk: this.client.provider.wallet.publicKey,
        bankPk: bank.publicKey,
        destinationTokenAccountPk: userTokenAtaPk
      },
      { amount: uiToNative(amount, bank.mintDecimals), withdrawAll },
      remainingAccounts
    );
    return { instructions: bank.mint.equals(NATIVE_MINT) ? await this.wrapInstructionForWSol(ix) : [ix], keys: [] };
  }
  /**
   * Withdraw collateral from the marginfi account.
   *
   * @param amount Amount to withdraw (UI unit)
   * @param bank Bank to withdraw from
   * @param withdrawAll (optional) Withdraw all the asset
   * @returns Transaction signature
   */
  async withdraw(amount, bank, withdrawAll = false) {
    const tx = new Transaction();
    if (withdrawAll && !bank.emissionsMint.equals(PublicKey3.default)) {
      const userAta2 = await associatedAddress({
        mint: bank.emissionsMint,
        owner: this.client.provider.wallet.publicKey
      });
      const createAtaIdempotentIx2 = createAssociatedTokenAccountIdempotentInstruction(
        this.client.provider.wallet.publicKey,
        userAta2,
        this.client.provider.wallet.publicKey,
        bank.emissionsMint
      );
      tx.add(createAtaIdempotentIx2);
      tx.add(...(await this.makeWithdrawEmissionsIx(bank)).instructions);
    }
    const userAta = await associatedAddress({
      mint: bank.mint,
      owner: this.client.provider.wallet.publicKey
    });
    const createAtaIdempotentIx = createAssociatedTokenAccountIdempotentInstruction(
      this.client.provider.wallet.publicKey,
      userAta,
      this.client.provider.wallet.publicKey,
      bank.mint
    );
    tx.add(createAtaIdempotentIx);
    const ixs = await this.makeWithdrawIx(amount, bank, withdrawAll);
    tx.add(...ixs.instructions);
    const sig = await this.client.processTransaction(tx);
    await this.reload();
    return sig;
  }
  /**
   * Create transaction instruction to withdraw collateral from the marginfi account.
   *
   * @param amount Amount to withdraw (mint native unit)
   * @param bank Bank to withdraw from
   * @returns `MarginWithdrawCollateral` transaction instruction
   */
  async makeBorrowIx(amount, bank, opt) {
    const userTokenAtaPk = await associatedAddress({
      mint: bank.mint,
      owner: this.client.provider.wallet.publicKey
    });
    const remainingAccounts = this.getHealthCheckAccounts(
      (opt?.remainingAccountsBankOverride?.length ?? 0) > 0 ? opt?.remainingAccountsBankOverride : [bank]
    );
    const ix = await instructions_default.makeBorrowIx(
      this._program,
      {
        marginfiGroupPk: this.group.publicKey,
        marginfiAccountPk: this.publicKey,
        signerPk: this.client.provider.wallet.publicKey,
        bankPk: bank.publicKey,
        destinationTokenAccountPk: userTokenAtaPk
      },
      { amount: uiToNative(amount, bank.mintDecimals) },
      remainingAccounts
    );
    return { instructions: bank.mint.equals(NATIVE_MINT) ? await this.wrapInstructionForWSol(ix) : [ix], keys: [] };
  }
  /**
   * Withdraw collateral from the marginfi account.
   *
   * @param amount Amount to withdraw (UI unit)
   * @param bank Bank to withdraw from
   * @returns Transaction signature
   */
  async borrow(amount, bank) {
    const tx = new Transaction();
    const userAta = await associatedAddress({
      mint: bank.mint,
      owner: this.client.provider.wallet.publicKey
    });
    const createAtaIdempotentIx = createAssociatedTokenAccountIdempotentInstruction(
      this.client.provider.wallet.publicKey,
      userAta,
      this.client.provider.wallet.publicKey,
      bank.mint
    );
    tx.add(createAtaIdempotentIx);
    const ixs = await this.makeBorrowIx(amount, bank);
    tx.add(...ixs.instructions);
    const sig = await this.client.processTransaction(tx);
    await this.reload();
    return sig;
  }
  async makeWithdrawEmissionsIx(bank) {
    const userAta = await associatedAddress({
      mint: bank.emissionsMint,
      owner: this.client.provider.wallet.publicKey
    });
    const ix = await instructions_default.makelendingAccountWithdrawEmissionIx(this._program, {
      marginfiGroup: this.group.publicKey,
      marginfiAccount: this.publicKey,
      signer: this.client.provider.wallet.publicKey,
      bank: bank.publicKey,
      destinationTokenAccount: userAta,
      emissionsMint: bank.emissionsMint
    });
    return { instructions: [ix], keys: [] };
  }
  async withdrawEmissions(bank) {
    const tx = new Transaction();
    const userAta = await associatedAddress({
      mint: bank.emissionsMint,
      owner: this.client.provider.wallet.publicKey
    });
    const createAtaIdempotentIx = createAssociatedTokenAccountIdempotentInstruction(
      this.client.provider.wallet.publicKey,
      userAta,
      this.client.provider.wallet.publicKey,
      bank.emissionsMint
    );
    tx.add(createAtaIdempotentIx);
    tx.add(...(await this.makeWithdrawEmissionsIx(bank)).instructions);
    const sig = await this.client.processTransaction(tx);
    await this.reload();
    return sig;
  }
  // --- Others
  getHealthCheckAccounts(mandatoryBanks = [], excludedBanks = []) {
    const mandatoryBanksSet = new Set(mandatoryBanks.map((b) => b.publicKey.toBase58()));
    const excludedBanksSet = new Set(excludedBanks.map((b) => b.publicKey.toBase58()));
    const activeBanks = new Set(this.activeBalances.map((b) => b.bankPk.toBase58()));
    const banksToAdd = new Set([...mandatoryBanksSet].filter((x) => !activeBanks.has(x)));
    let slotsToKeep = banksToAdd.size;
    return this._lendingBalances.filter((balance) => {
      if (balance.active) {
        return !excludedBanksSet.has(balance.bankPk.toBase58());
      } else if (slotsToKeep > 0) {
        slotsToKeep--;
        return true;
      } else {
        return false;
      }
    }).map((balance) => {
      if (balance.active) {
        return balance.bankPk.toBase58();
      }
      const newBank = [...banksToAdd.values()][0];
      banksToAdd.delete(newBank);
      return newBank;
    }).flatMap((bankPk) => {
      const bank = this._group.getBankByPk(bankPk);
      if (bank === null)
        throw Error(`Could not find bank ${bankPk}`);
      return [
        {
          pubkey: new PublicKey3(bankPk),
          isSigner: false,
          isWritable: false
        },
        {
          pubkey: bank.config.oracleKeys[0],
          isSigner: false,
          isWritable: false
        }
      ];
    });
  }
  /**
   * Fetch marginfi account data.
   * Check sanity against provided config.
   *
   * @param accountAddress account address
   * @param config marginfi config
   * @param program marginfi Anchor program
   * @param commitment commitment override
   * @returns Decoded marginfi account data struct
   */
  static async _fetchAccountData(accountAddress, config, program, commitment) {
    const mergedCommitment = commitment ?? program.provider.connection.commitment ?? DEFAULT_COMMITMENT;
    const data = await program.account.marginfiAccount.fetch(
      accountAddress,
      mergedCommitment
    );
    if (!data.group.equals(config.groupPk))
      throw Error(`Marginfi account tied to group ${data.group.toBase58()}. Expected: ${config.groupPk.toBase58()}`);
    return data;
  }
  /**
   * Decode marginfi account data according to the Anchor IDL.
   *
   * @param encoded Raw data buffer
   * @returns Decoded marginfi account data struct
   */
  static decode(encoded) {
    const coder = new BorshCoder(IDL);
    return coder.accounts.decode("marginfiAccount" /* MarginfiAccount */, encoded);
  }
  /**
   * Decode marginfi account data according to the Anchor IDL.
   *
   * @param decoded Marginfi account data struct
   * @returns Raw data buffer
   */
  static async encode(decoded) {
    const coder = new BorshCoder(IDL);
    return await coder.accounts.encode("marginfiAccount" /* MarginfiAccount */, decoded);
  }
  /**
   * Update instance data by fetching and storing the latest on-chain state.
   */
  async reload() {
    const [marginfiGroupAi, marginfiAccountAi] = await this._loadGroupAndAccountAi();
    const marginfiAccountData = MarginfiAccount.decode(marginfiAccountAi.data);
    if (!marginfiAccountData.group.equals(this._config.groupPk))
      throw Error(
        `Marginfi account tied to group ${marginfiAccountData.group.toBase58()}. Expected: ${this._config.groupPk.toBase58()}`
      );
    const bankAccountsData = await this._program.account.bank.all([
      { memcmp: { offset: 8 + 32 + 1, bytes: this._config.groupPk.toBase58() } }
    ]);
    const banks = await Promise.all(
      bankAccountsData.map(async (accountData) => {
        let bankData = accountData.account;
        return new Bank(
          this._config.banks.find((b) => b.address.equals(accountData.publicKey))?.label || "Unknown",
          accountData.publicKey,
          bankData,
          await getOraclePriceData(
            this._program.provider.connection,
            bankData.config.oracleSetup,
            bankData.config.oracleKeys
          )
        );
      })
    );
    this._group = group_default.fromAccountDataRaw(this._config, this._program, marginfiGroupAi.data, banks);
    this._updateFromAccountData(marginfiAccountData);
  }
  /**
   * Update instance data from provided data struct.
   *
   * @param data Marginfi account data struct
   */
  _updateFromAccountData(data) {
    this._authority = data.authority;
    this._lendingBalances = data.lendingAccount.balances.map((la) => new Balance(la));
  }
  async _loadGroupAndAccountAi() {
    let [marginfiGroupAi, marginfiAccountAi] = await this.client.provider.connection.getMultipleAccountsInfo(
      [this._config.groupPk, this.publicKey],
      DEFAULT_COMMITMENT
    );
    if (!marginfiAccountAi) {
      throw Error("Marginfi account no found");
    }
    if (!marginfiGroupAi) {
      throw Error("Marginfi Group Account no found");
    }
    return [marginfiGroupAi, marginfiAccountAi];
  }
  getHealthComponents(marginReqType) {
    const [assets, liabilities] = this.activeBalances.map((accountBalance) => {
      const bank = this._group.banks.get(accountBalance.bankPk.toBase58());
      if (!bank)
        throw Error(`Bank ${shortenAddress(accountBalance.bankPk)} not found`);
      const { assets: assets2, liabilities: liabilities2 } = accountBalance.getUsdValueWithPriceBias(bank, marginReqType);
      return [assets2, liabilities2];
    }).reduce(
      ([asset, liability], [d, l]) => {
        return [asset.plus(d), liability.plus(l)];
      },
      [new BigNumber(0), new BigNumber(0)]
    );
    return { assets, liabilities };
  }
  canBeLiquidated() {
    const { assets, liabilities } = this.getHealthComponents(1 /* Maint */);
    return assets.lt(liabilities);
  }
  getBalance(bankPk) {
    return this.activeBalances.find((b) => b.bankPk.equals(bankPk)) ?? Balance.newEmpty(bankPk);
  }
  getFreeCollateral() {
    const { assets, liabilities } = this.getHealthComponents(0 /* Init */);
    return BigNumber.max(0, assets.minus(liabilities));
  }
  _getHealthComponentsWithoutBias(marginReqType) {
    const [assets, liabilities] = this.activeBalances.map((accountBalance) => {
      const bank = this._group.banks.get(accountBalance.bankPk.toBase58());
      if (!bank)
        throw Error(`Bank ${shortenAddress(accountBalance.bankPk)} not found`);
      const { assets: assets2, liabilities: liabilities2 } = accountBalance.getUsdValue(bank, marginReqType);
      return [assets2, liabilities2];
    }).reduce(
      ([asset, liability], [d, l]) => {
        return [asset.plus(d), liability.plus(l)];
      },
      [new BigNumber(0), new BigNumber(0)]
    );
    return { assets, liabilities };
  }
  computeNetApy() {
    const { assets, liabilities } = this._getHealthComponentsWithoutBias(2 /* Equity */);
    const totalUsdValue = assets.minus(liabilities);
    const apr = this.activeBalances.reduce((weightedApr, balance) => {
      const bank = this._group.getBankByPk(balance.bankPk);
      if (!bank)
        throw Error(`Bank ${balance.bankPk.toBase58()} not found`);
      return weightedApr.minus(
        bank.getInterestRates().borrowingRate.times(balance.getUsdValue(bank, 2 /* Equity */).liabilities).div(totalUsdValue.isEqualTo(0) ? 1 : totalUsdValue)
      ).plus(
        bank.getInterestRates().lendingRate.times(balance.getUsdValue(bank, 2 /* Equity */).assets).div(totalUsdValue.isEqualTo(0) ? 1 : totalUsdValue)
      );
    }, new BigNumber(0)).toNumber();
    return aprToApy(apr);
  }
  /**
   * Calculate the maximum amount of asset that can be withdrawn from a bank given existing deposits of the asset
   * and the untied collateral of the margin account.
   *
   * fc = free collateral
   * ucb = untied collateral for bank
   *
   * q = (min(fc, ucb) / (price_lowest_bias * deposit_weight)) + (fc - min(fc, ucb)) / (price_highest_bias * liab_weight)
   *
   *
   *
   * NOTE FOR LIQUIDATORS
   * This function doesn't take into account the collateral received when liquidating an account.
   */
  getMaxBorrowForBank(bank) {
    const balance = this.getBalance(bank.publicKey);
    const freeCollateral = this.getFreeCollateral();
    const untiedCollateralForBank = BigNumber.min(
      bank.getAssetUsdValue(balance.assetShares, 0 /* Init */, 0 /* Lowest */),
      freeCollateral
    );
    const priceLowestBias = bank.getPrice(0 /* Lowest */);
    const priceHighestBias = bank.getPrice(2 /* Highest */);
    const assetWeight = bank.getAssetWeight(0 /* Init */);
    const liabWeight = bank.getLiabilityWeight(0 /* Init */);
    if (assetWeight.eq(0)) {
      return balance.getQuantityUi(bank).assets.plus(freeCollateral.minus(untiedCollateralForBank).div(priceHighestBias.times(liabWeight)));
    } else {
      return untiedCollateralForBank.div(priceLowestBias.times(assetWeight)).plus(freeCollateral.minus(untiedCollateralForBank).div(priceHighestBias.times(liabWeight)));
    }
  }
  /**
   * Calculate the maximum amount that can be withdrawn form a bank without borrowing.
   */
  getMaxWithdrawForBank(bank) {
    const assetWeight = bank.getAssetWeight(0 /* Init */);
    const balance = this.getBalance(bank.publicKey);
    if (assetWeight.eq(0)) {
      return balance.getQuantityUi(bank).assets;
    } else {
      const freeCollateral = this.getFreeCollateral();
      const untiedCollateralForBank = BigNumber.min(
        bank.getAssetUsdValue(balance.assetShares, 0 /* Init */, 0 /* Lowest */),
        freeCollateral
      );
      const priceLowestBias = bank.getPrice(0 /* Lowest */);
      return untiedCollateralForBank.div(priceLowestBias.times(assetWeight));
    }
  }
  async makeLendingAccountLiquidateIx(liquidateeMarginfiAccount, assetBank, assetQuantityUi, liabBank) {
    const ix = await instructions_default.makeLendingAccountLiquidateIx(
      this._program,
      {
        marginfiGroup: this._config.groupPk,
        signer: this.client.provider.wallet.publicKey,
        assetBank: assetBank.publicKey,
        liabBank: liabBank.publicKey,
        liquidatorMarginfiAccount: this.publicKey,
        liquidateeMarginfiAccount: liquidateeMarginfiAccount.publicKey
      },
      { assetAmount: uiToNative(assetQuantityUi, assetBank.mintDecimals) },
      [
        {
          pubkey: assetBank.config.oracleKeys[0],
          isSigner: false,
          isWritable: false
        },
        {
          pubkey: liabBank.config.oracleKeys[0],
          isSigner: false,
          isWritable: false
        },
        ...this.getHealthCheckAccounts([assetBank, liabBank]),
        ...liquidateeMarginfiAccount.getHealthCheckAccounts()
      ]
    );
    return { instructions: [ix], keys: [] };
  }
  async lendingAccountLiquidate(liquidateeMarginfiAccount, assetBank, assetQuantityUi, liabBank) {
    const ixw = await this.makeLendingAccountLiquidateIx(
      liquidateeMarginfiAccount,
      assetBank,
      assetQuantityUi,
      liabBank
    );
    const tx = new Transaction().add(...ixw.instructions, ComputeBudgetProgram.setComputeUnitLimit({ units: 6e5 }));
    return this.client.processTransaction(tx);
  }
  toString() {
    const { assets, liabilities } = this.getHealthComponents(2 /* Equity */);
    let str = `-----------------
  Marginfi account:
    Address: ${this.publicKey.toBase58()}
    Group: ${this.group.publicKey.toBase58()}
    Authority: ${this.authority.toBase58()}
    Equity: ${this.getHealthComponents(2 /* Equity */).assets.toFixed(6)}
    Equity: ${assets.minus(liabilities).toFixed(6)}
    Assets: ${assets.toFixed(6)},
    Liabilities: ${liabilities.toFixed(6)}`;
    const activeLendingAccounts = this.activeBalances.filter((la) => la.active);
    if (activeLendingAccounts.length > 0) {
      str = str.concat("\n-----------------\nBalances:");
    }
    for (let lendingAccount of activeLendingAccounts) {
      const bank = this._group.getBankByPk(lendingAccount.bankPk);
      if (!bank) {
        console.log(`Bank ${lendingAccount.bankPk} not found`);
        continue;
      }
      const utpStr = `
  Bank ${bank.label}:
      Address: ${bank.publicKey.toBase58()}
      Mint: ${bank.mint.toBase58()}
      Equity: ${lendingAccount.getUsdValue(bank, 2 /* Equity */)}`;
      str = str.concat(utpStr);
    }
    return str;
  }
  // Calculate the max amount of collateral to liquidate to bring an account maint health to 0 (assuming negative health).
  //
  // The asset amount is bounded by 2 constraints,
  // (1) the amount of liquidated collateral cannot be more than the balance,
  // (2) the amount of covered liablity cannot be more than existing liablity.
  getMaxLiquidatableAssetAmount(assetBank, liabBank) {
    const { assets, liabilities } = this.getHealthComponents(1 /* Maint */);
    const currentHealth = assets.minus(liabilities);
    const priceAssetLower = assetBank.getPrice(0 /* Lowest */);
    const priceAssetMarket = assetBank.getPrice(1 /* None */);
    const assetMaintWeight = assetBank.config.assetWeightMaint;
    const liquidationDiscount = new BigNumber(1 - 0.05);
    const priceLiabHighest = liabBank.getPrice(2 /* Highest */);
    const priceLiabMarket = liabBank.getPrice(1 /* None */);
    const liabMaintWeight = liabBank.config.liabilityWeightMaint;
    const maxLiquidatableUnboundedAssetAmount = currentHealth.div(
      priceAssetLower.times(assetMaintWeight).minus(
        priceAssetMarket.times(liquidationDiscount).times(priceLiabHighest).times(liabMaintWeight).div(priceLiabMarket)
      )
    );
    const assetBalanceBound = this.getBalance(assetBank.publicKey).getQuantityUi(assetBank).assets;
    const liabBalance = this.getBalance(liabBank.publicKey).getQuantityUi(liabBank).liabilities;
    const liabBalanceBound = liabBalance.times(priceLiabMarket).div(priceAssetMarket.times(liquidationDiscount));
    return BigNumber.min(assetBalanceBound, liabBalanceBound, maxLiquidatableUnboundedAssetAmount);
  }
  describe() {
    const { assets, liabilities } = this.getHealthComponents(2 /* Equity */);
    return `
- Marginfi account: ${this.publicKey}
- Total deposits: $${assets.toFixed(6)}
- Total liabilities: $${liabilities.toFixed(6)}
- Equity: $${assets.minus(liabilities).toFixed(6)}
- Health: ${assets.minus(liabilities).div(assets).times(100).toFixed(2)}%
- Balances:  ${this.activeBalances.map((la) => {
      const bank = this._group.getBankByPk(la.bankPk);
      return la.describe(bank);
    })}`;
  }
  async wrapInstructionForWSol(ix, amount = new BigNumber(0)) {
    return [...await this.makeWrapSolIxs(new BigNumber(amount)), ix, await this.makeUnwrapSolIx()];
  }
  async makeWrapSolIxs(amount) {
    const address = await associatedAddress({ mint: NATIVE_MINT, owner: this.client.wallet.publicKey });
    const ixs = [
      createAssociatedTokenAccountIdempotentInstruction(
        this.client.wallet.publicKey,
        address,
        this.client.wallet.publicKey,
        NATIVE_MINT
      )
    ];
    if (amount.gt(0)) {
      const nativeAmount = uiToNative(amount, 9).toNumber() + 1e4;
      ixs.push(
        SystemProgram2.transfer({ fromPubkey: this.client.wallet.publicKey, toPubkey: address, lamports: nativeAmount }),
        createSyncNativeInstruction(address)
      );
    }
    return ixs;
  }
  async makeUnwrapSolIx() {
    const address = await associatedAddress({ mint: NATIVE_MINT, owner: this.client.wallet.publicKey });
    return createCloseAccountInstruction(address, this.client.wallet.publicKey, this.client.wallet.publicKey);
  }
};
var account_default = MarginfiAccount;
var Balance = class {
  constructor(data) {
    this.active = data.active;
    this.bankPk = data.bankPk;
    this.assetShares = wrappedI80F48toBigNumber(data.assetShares);
    this.liabilityShares = wrappedI80F48toBigNumber(data.liabilityShares);
    this.emissionsOutstanding = wrappedI80F48toBigNumber(data.emissionsOutstanding);
    this.lastUpdate = data.lastUpdate;
  }
  static newEmpty(bankPk) {
    return new Balance({
      active: false,
      bankPk,
      assetShares: { value: new BN(0) },
      liabilityShares: { value: new BN(0) },
      emissionsOutstanding: { value: new BN(0) },
      lastUpdate: 0
    });
  }
  getUsdValue(bank, marginReqType = 2 /* Equity */) {
    return {
      assets: bank.getAssetUsdValue(this.assetShares, marginReqType, 1 /* None */),
      liabilities: bank.getLiabilityUsdValue(this.liabilityShares, marginReqType, 1 /* None */)
    };
  }
  getUsdValueWithPriceBias(bank, marginReqType) {
    return {
      assets: bank.getAssetUsdValue(this.assetShares, marginReqType, 0 /* Lowest */),
      liabilities: bank.getLiabilityUsdValue(this.liabilityShares, marginReqType, 2 /* Highest */)
    };
  }
  getQuantity(bank) {
    return {
      assets: bank.getAssetQuantity(this.assetShares),
      liabilities: bank.getLiabilityQuantity(this.liabilityShares)
    };
  }
  getQuantityUi(bank) {
    return {
      assets: new BigNumber(nativeToUi(bank.getAssetQuantity(this.assetShares), bank.mintDecimals)),
      liabilities: new BigNumber(nativeToUi(bank.getLiabilityQuantity(this.liabilityShares), bank.mintDecimals))
    };
  }
  getTotalOutstandingEmissions(bank) {
    const claimedEmissions = this.emissionsOutstanding;
    const unclaimedEmissions = this.calcClaimedEmissions(bank, Date.now() / 1e3);
    return claimedEmissions.plus(unclaimedEmissions);
  }
  calcClaimedEmissions(bank, currentTimestamp) {
    const lendingActive = bank.emissionsActiveLending;
    const borrowActive = bank.emissionsActiveBorrowing;
    const { assets, liabilities } = this.getQuantity(bank);
    let balanceAmount = null;
    if (lendingActive) {
      balanceAmount = assets;
    } else if (borrowActive) {
      balanceAmount = liabilities;
    }
    if (balanceAmount) {
      const lastUpdate = this.lastUpdate;
      const period = new BigNumber(currentTimestamp - lastUpdate);
      const emissionsRate = new BigNumber(bank.emissionsRate);
      const emissions = period.times(balanceAmount).times(emissionsRate).div(31536e9);
      const emissionsReal = BigNumber.min(emissions, new BigNumber(bank.emissionsRemaining));
      return emissionsReal;
    }
    return new BigNumber(0);
  }
  describe(bank) {
    let { assets: assetsQt, liabilities: liabsQt } = this.getQuantityUi(bank);
    let { assets: assetsUsd, liabilities: liabsUsd } = this.getUsdValue(bank, 2 /* Equity */);
    return `
${bank.label} Balance:
- Deposits: ${assetsQt.toFixed(5)} (${assetsUsd.toFixed(5)} USD)
- Borrows: ${liabsQt.toFixed(5)} (${liabsUsd.toFixed(5)} USD)
`;
  }
};
var MarginRequirementType = /* @__PURE__ */ ((MarginRequirementType2) => {
  MarginRequirementType2[MarginRequirementType2["Init"] = 0] = "Init";
  MarginRequirementType2[MarginRequirementType2["Maint"] = 1] = "Maint";
  MarginRequirementType2[MarginRequirementType2["Equity"] = 2] = "Equity";
  return MarginRequirementType2;
})(MarginRequirementType || {});

// src/constants.ts
import BigNumber2 from "bignumber.js";
var PDA_BANK_LIQUIDITY_VAULT_AUTH_SEED = Buffer.from("liquidity_vault_auth");
var PDA_BANK_INSURANCE_VAULT_AUTH_SEED = Buffer.from("insurance_vault_auth");
var PDA_BANK_FEE_VAULT_AUTH_SEED = Buffer.from("fee_vault_auth");
var PDA_BANK_LIQUIDITY_VAULT_SEED = Buffer.from("liquidity_vault");
var PDA_BANK_INSURANCE_VAULT_SEED = Buffer.from("insurance_vault");
var PDA_BANK_FEE_VAULT_SEED = Buffer.from("fee_vault");
var PYTH_PRICE_CONF_INTERVALS = new BigNumber2(2.12);
var SWB_PRICE_CONF_INTERVALS = new BigNumber2(2.12);
var USDC_DECIMALS = 6;

// src/bank.ts
import { parsePriceData } from "@pythnetwork/client";
import { getMint, nativeToUi as nativeToUi2, wrappedI80F48toBigNumber as wrappedI80F48toBigNumber2 } from "@mrgnlabs/mrgn-common";
import { AggregatorAccount, SwitchboardProgram } from "@switchboard-xyz/solana.js";
var Bank = class {
  constructor(label, address, rawData, priceData) {
    this.label = label;
    this.publicKey = address;
    this.mint = rawData.mint;
    this.mintDecimals = rawData.mintDecimals;
    this.group = rawData.group;
    this.assetShareValue = wrappedI80F48toBigNumber2(rawData.assetShareValue);
    this.liabilityShareValue = wrappedI80F48toBigNumber2(rawData.liabilityShareValue);
    this.liquidityVault = rawData.liquidityVault;
    this.liquidityVaultBump = rawData.liquidityVaultBump;
    this.liquidityVaultAuthorityBump = rawData.liquidityVaultAuthorityBump;
    this.insuranceVault = rawData.insuranceVault;
    this.insuranceVaultBump = rawData.insuranceVaultBump;
    this.insuranceVaultAuthorityBump = rawData.insuranceVaultAuthorityBump;
    this.collectedInsuranceFeesOutstanding = wrappedI80F48toBigNumber2(rawData.collectedInsuranceFeesOutstanding);
    this.feeVault = rawData.feeVault;
    this.feeVaultBump = rawData.feeVaultBump;
    this.feeVaultAuthorityBump = rawData.feeVaultAuthorityBump;
    this.collectedGroupFeesOutstanding = wrappedI80F48toBigNumber2(rawData.collectedGroupFeesOutstanding);
    this.config = {
      assetWeightInit: wrappedI80F48toBigNumber2(rawData.config.assetWeightInit),
      assetWeightMaint: wrappedI80F48toBigNumber2(rawData.config.assetWeightMaint),
      liabilityWeightInit: wrappedI80F48toBigNumber2(rawData.config.liabilityWeightInit),
      liabilityWeightMaint: wrappedI80F48toBigNumber2(rawData.config.liabilityWeightMaint),
      depositLimit: nativeToUi2(rawData.config.depositLimit, this.mintDecimals),
      oracleSetup: rawData.config.oracleSetup,
      oracleKeys: rawData.config.oracleKeys,
      interestRateConfig: {
        insuranceFeeFixedApr: wrappedI80F48toBigNumber2(rawData.config.interestRateConfig.insuranceFeeFixedApr),
        maxInterestRate: wrappedI80F48toBigNumber2(rawData.config.interestRateConfig.maxInterestRate),
        insuranceIrFee: wrappedI80F48toBigNumber2(rawData.config.interestRateConfig.insuranceIrFee),
        optimalUtilizationRate: wrappedI80F48toBigNumber2(rawData.config.interestRateConfig.optimalUtilizationRate),
        plateauInterestRate: wrappedI80F48toBigNumber2(rawData.config.interestRateConfig.plateauInterestRate),
        protocolFixedFeeApr: wrappedI80F48toBigNumber2(rawData.config.interestRateConfig.protocolFixedFeeApr),
        protocolIrFee: wrappedI80F48toBigNumber2(rawData.config.interestRateConfig.protocolIrFee)
      }
    };
    this.totalAssetShares = wrappedI80F48toBigNumber2(rawData.totalAssetShares);
    this.totalLiabilityShares = wrappedI80F48toBigNumber2(rawData.totalLiabilityShares);
    this.priceData = priceData;
    const emissionsFlags = rawData.emissionsFlags.toNumber();
    this.emissionsActiveBorrowing = (emissionsFlags & 1) > 0;
    this.emissionsActiveLending = (emissionsFlags & 2) > 0;
    this.emissionsRate = rawData.emissionsRate.toNumber();
    this.emissionsMint = rawData.emissionsMint;
    this.emissionsRemaining = rawData.emissionsRemaining ? wrappedI80F48toBigNumber2(rawData.emissionsRemaining) : new BigNumber3(0);
  }
  describe() {
    return `
Bank: ${this.label}, address: ${this.publicKey.toBase58()}
Mint: ${this.mint.toBase58()}, decimals: ${this.mintDecimals}

Total deposits: ${nativeToUi2(this.totalAssets, this.mintDecimals)}
Total borrows: ${nativeToUi2(this.totalLiabilities, this.mintDecimals)}

Total assets (USD value): ${this.getAssetUsdValue(this.totalAssetShares, 2 /* Equity */, 1 /* None */)}
Total liabilities (USD value): ${this.getLiabilityUsdValue(
      this.totalLiabilityShares,
      2 /* Equity */,
      1 /* None */
    )}

Asset price (USD): ${this.getPrice(1 /* None */)}

Config:
- Asset weight init: ${this.config.assetWeightInit.toFixed(2)}
- Asset weight maint: ${this.config.assetWeightMaint.toFixed(2)}
- Liability weight init: ${this.config.liabilityWeightInit.toFixed(2)}
- Liability weight maint: ${this.config.liabilityWeightMaint.toFixed(2)}
- Max capacity: ${this.config.depositLimit}

LTVs:
- Initial: ${new BigNumber3(1).div(this.config.liabilityWeightInit).times(100).toFixed(2)}%
- Maintenance: ${new BigNumber3(1).div(this.config.liabilityWeightMaint).times(100).toFixed(2)}%
`;
  }
  get totalAssets() {
    return this.getAssetQuantity(this.totalAssetShares);
  }
  get totalLiabilities() {
    return this.getLiabilityQuantity(this.totalLiabilityShares);
  }
  async reloadPriceData(connection) {
    this.priceData = await getOraclePriceData(connection, this.config.oracleSetup, this.config.oracleKeys);
  }
  getAssetQuantity(assetShares) {
    return assetShares.times(this.assetShareValue);
  }
  getLiabilityQuantity(liabilityShares) {
    return liabilityShares.times(this.liabilityShareValue);
  }
  getAssetShares(assetValue) {
    return assetValue.div(this.assetShareValue);
  }
  getLiabilityShares(liabilityValue) {
    return liabilityValue.div(this.liabilityShareValue);
  }
  getAssetUsdValue(assetShares, marginRequirementType, priceBias) {
    return this.getUsdValue(this.getAssetQuantity(assetShares), priceBias, this.getAssetWeight(marginRequirementType));
  }
  getLiabilityUsdValue(liabilityShares, marginRequirementType, priceBias) {
    return this.getUsdValue(
      this.getLiabilityQuantity(liabilityShares),
      priceBias,
      this.getLiabilityWeight(marginRequirementType)
    );
  }
  getUsdValue(quantity, priceBias, weight, scaleToBase = true) {
    const price = this.getPrice(priceBias);
    return quantity.times(price).times(weight ?? 1).dividedBy(scaleToBase ? 10 ** this.mintDecimals : 1);
  }
  getPrice(priceBias = 1 /* None */) {
    switch (priceBias) {
      case 0 /* Lowest */:
        return this.priceData.lowestPrice;
      case 2 /* Highest */:
        return this.priceData.highestPrice;
      case 1 /* None */:
        return this.priceData.price;
    }
  }
  // Return asset weight based on margin requirement types
  getAssetWeight(marginRequirementType) {
    switch (marginRequirementType) {
      case 0 /* Init */:
        return this.config.assetWeightInit;
      case 1 /* Maint */:
        return this.config.assetWeightMaint;
      case 2 /* Equity */:
        return new BigNumber3(1);
      default:
        throw new Error("Invalid margin requirement type");
    }
  }
  getLiabilityWeight(marginRequirementType) {
    switch (marginRequirementType) {
      case 0 /* Init */:
        return this.config.liabilityWeightInit;
      case 1 /* Maint */:
        return this.config.liabilityWeightMaint;
      case 2 /* Equity */:
        return new BigNumber3(1);
      default:
        throw new Error("Invalid margin requirement type");
    }
  }
  getQuantityFromUsdValue(usdValue, priceBias) {
    const price = this.getPrice(priceBias);
    return usdValue.div(price);
  }
  getInterestRates() {
    const { insuranceFeeFixedApr, insuranceIrFee, protocolFixedFeeApr, protocolIrFee } = this.config.interestRateConfig;
    const rateFee = insuranceFeeFixedApr.plus(protocolFixedFeeApr);
    const fixedFee = insuranceIrFee.plus(protocolIrFee);
    const interestRate = this.interestRateCurve();
    const utilizationRate = this.getUtilizationRate();
    const lendingRate = interestRate.times(utilizationRate);
    const borrowingRate = interestRate.times(new BigNumber3(1).plus(rateFee)).plus(fixedFee);
    return { lendingRate, borrowingRate };
  }
  interestRateCurve() {
    const { optimalUtilizationRate, plateauInterestRate, maxInterestRate } = this.config.interestRateConfig;
    const utilizationRate = this.getUtilizationRate();
    if (utilizationRate.lte(optimalUtilizationRate)) {
      return utilizationRate.times(plateauInterestRate).div(optimalUtilizationRate);
    } else {
      return utilizationRate.minus(optimalUtilizationRate).div(new BigNumber3(1).minus(optimalUtilizationRate)).times(maxInterestRate.minus(plateauInterestRate)).plus(plateauInterestRate);
    }
  }
  getUtilizationRate() {
    return this.totalLiabilities.div(this.totalAssets);
  }
  async getEmissionsData(connection) {
    const mint = await getMint(connection, this.emissionsMint);
    const remainingUi = this.emissionsRemaining.div(10 ** mint.decimals);
    let rateUi = this.emissionsRate / 10 ** mint.decimals;
    let bankMintDiff = this.mintDecimals - 6;
    if (bankMintDiff > 0) {
      rateUi = rateUi * 10 ** bankMintDiff;
    } else if (bankMintDiff < 0) {
      rateUi = rateUi * 10 ** bankMintDiff;
    }
    return {
      lendingActive: this.emissionsActiveLending,
      borrowingActive: this.emissionsActiveBorrowing,
      rateUi: new BigNumber3(rateUi),
      remainingUi
    };
  }
};
var OracleSetup = /* @__PURE__ */ ((OracleSetup2) => {
  OracleSetup2[OracleSetup2["None"] = 0] = "None";
  OracleSetup2[OracleSetup2["PythEma"] = 1] = "PythEma";
  OracleSetup2[OracleSetup2["SwitchboardV2"] = 2] = "SwitchboardV2";
  return OracleSetup2;
})(OracleSetup || {});
var PriceBias = /* @__PURE__ */ ((PriceBias2) => {
  PriceBias2[PriceBias2["Lowest"] = 0] = "Lowest";
  PriceBias2[PriceBias2["None"] = 1] = "None";
  PriceBias2[PriceBias2["Highest"] = 2] = "Highest";
  return PriceBias2;
})(PriceBias || {});
async function getOraclePriceData(connection, oracleSetup, oracleKeys) {
  switch (oracleSetup) {
    case 1 /* PythEma */:
      const account = await connection.getAccountInfo(oracleKeys[0]);
      const pythPriceData = parsePriceData(account.data);
      const pythPrice = new BigNumber3(pythPriceData.emaPrice.value);
      const pythConfInterval = new BigNumber3(pythPriceData.emaConfidence.value);
      const pythLowestPrice = pythPrice.minus(pythConfInterval.times(PYTH_PRICE_CONF_INTERVALS));
      const pythHighestPrice = pythPrice.plus(pythConfInterval.times(PYTH_PRICE_CONF_INTERVALS));
      return {
        price: pythPrice,
        confidenceInterval: pythConfInterval,
        lowestPrice: pythLowestPrice,
        highestPrice: pythHighestPrice
      };
    case 2 /* SwitchboardV2 */:
      const swbProgram = await SwitchboardProgram.load("mainnet-beta", connection);
      const aggAccount = new AggregatorAccount(swbProgram, oracleKeys[0]);
      const aggData = await aggAccount.loadData();
      const swbPrice = new BigNumber3(AggregatorAccount.decodeLatestValue(aggData).toString());
      const swbConfidence = new BigNumber3(aggData.latestConfirmedRound.stdDeviation.toBig().toString());
      const swbLowestPrice = swbPrice.minus(swbConfidence.times(SWB_PRICE_CONF_INTERVALS));
      const swbHighestPrice = swbPrice.plus(swbConfidence.times(SWB_PRICE_CONF_INTERVALS));
      return {
        price: swbPrice,
        confidenceInterval: swbConfidence,
        lowestPrice: swbLowestPrice,
        highestPrice: swbHighestPrice
      };
    default:
      console.log("Invalid oracle setup", oracleSetup);
      throw new Error(`Invalid oracle setup "${oracleSetup}"`);
  }
}

// src/group.ts
import { DEFAULT_COMMITMENT as DEFAULT_COMMITMENT2 } from "@mrgnlabs/mrgn-common";
var MarginfiGroup = class {
  /**
   * @internal
   */
  constructor(config, program, rawData, banks) {
    this.publicKey = config.groupPk;
    this._config = config;
    this._program = program;
    this._admin = rawData.admin;
    this._banks = banks.reduce((acc, current) => {
      acc.set(current.publicKey.toBase58(), current);
      return acc;
    }, /* @__PURE__ */ new Map());
  }
  // --- Getters / Setters
  /**
   * Marginfi account authority address
   */
  get admin() {
    return this._admin;
  }
  get banks() {
    return this._banks;
  }
  // --- Factories
  /**
   * MarginfiGroup network factory
   *
   * Fetch account data according to the config and instantiate the corresponding MarginfiGroup.
   *
   * @param config marginfi config
   * @param program marginfi Anchor program
   * @param commitment Commitment level override
   * @return MarginfiGroup instance
   */
  static async fetch(config, program, commitment) {
    const accountData = await MarginfiGroup._fetchAccountData(config, program, commitment);
    const bankAccountsData = await program.account.bank.all([
      { memcmp: { offset: 8 + 32 + 1, bytes: config.groupPk.toBase58() } }
    ]);
    const banks = await Promise.all(
      bankAccountsData.map(async (accountData2) => {
        let bankData = accountData2.account;
        return new Bank(
          config.banks.find((b) => b.address.equals(accountData2.publicKey))?.label || "Unknown",
          accountData2.publicKey,
          bankData,
          await getOraclePriceData(program.provider.connection, bankData.config.oracleSetup, bankData.config.oracleKeys)
        );
      })
    );
    return new MarginfiGroup(config, program, accountData, banks);
  }
  /**
   * MarginfiGroup local factory (decoded)
   *
   * Instantiate a MarginfiGroup according to the provided decoded data.
   * Check sanity against provided config.
   *
   * @param config marginfi config
   * @param program marginfi Anchor program
   * @param accountData Decoded marginfi group data
   * @param banks Asset banks
   * @return MarginfiGroup instance
   */
  static fromAccountData(config, program, accountData, banks) {
    return new MarginfiGroup(config, program, accountData, banks);
  }
  /**
   * MarginfiGroup local factory (encoded)
   *
   * Instantiate a MarginfiGroup according to the provided encoded data.
   * Check sanity against provided config.
   *
   * @param config marginfi config
   * @param program marginfi Anchor program
   * @param rawData Encoded marginfi group data
   * @param banks Asset banks
   * @return MarginfiGroup instance
   */
  static fromAccountDataRaw(config, program, rawData, banks) {
    const data = MarginfiGroup.decode(rawData);
    return MarginfiGroup.fromAccountData(config, program, data, banks);
  }
  // --- Others
  /**
   * Fetch marginfi group account data according to the config.
   * Check sanity against provided config.
   *
   * @param config marginfi config
   * @param program marginfi Anchor program
   * @param commitment Commitment level override
   * @return Decoded marginfi group account data struct
   */
  static async _fetchAccountData(config, program, commitment) {
    const mergedCommitment = commitment ?? program.provider.connection.commitment ?? DEFAULT_COMMITMENT2;
    return await program.account.marginfiGroup.fetch(config.groupPk, mergedCommitment);
  }
  /**
   * Decode marginfi group account data according to the Anchor IDL.
   *
   * @param encoded Raw data buffer
   * @return Decoded marginfi group account data struct
   */
  static decode(encoded) {
    const coder = new BorshCoder2(IDL);
    return coder.accounts.decode("marginfiGroup" /* MarginfiGroup */, encoded);
  }
  /**
   * Encode marginfi group account data according to the Anchor IDL.
   *
   * @param decoded Encoded marginfi group account data buffer
   * @return Raw data buffer
   */
  static async encode(decoded) {
    const coder = new BorshCoder2(IDL);
    return await coder.accounts.encode("marginfiGroup" /* MarginfiGroup */, decoded);
  }
  /**
   * Update instance data by fetching and storing the latest on-chain state.
   */
  async reload(commitment) {
    const rawData = await MarginfiGroup._fetchAccountData(this._config, this._program, commitment);
    const bankAddresses = this._config.banks.map((b) => b.address);
    let bankAccountsData = await this._program.account.bank.all([
      { memcmp: { offset: 8 + 32 + 1, bytes: this._config.groupPk.toBase58() } }
    ]);
    let nullAccounts = [];
    for (let i = 0; i < bankAccountsData.length; i++) {
      if (bankAccountsData[i] === null)
        nullAccounts.push(bankAddresses[i]);
    }
    if (nullAccounts.length > 0) {
      throw Error(`Failed to fetch banks ${nullAccounts}`);
    }
    const banks = await Promise.all(
      bankAccountsData.map(async (accountData) => {
        let bankData = accountData.account;
        return new Bank(
          this._config.banks.find((b) => b.address.equals(accountData.publicKey))?.label || "Unknown",
          accountData.publicKey,
          bankData,
          await getOraclePriceData(
            this._program.provider.connection,
            bankData.config.oracleSetup,
            bankData.config.oracleKeys
          )
        );
      })
    );
    this._admin = rawData.admin;
    this._banks = banks.reduce((acc, current) => {
      acc.set(current.publicKey.toBase58(), current);
      return acc;
    }, /* @__PURE__ */ new Map());
  }
  /**
   * Get bank by label.
   */
  getBankByLabel(label) {
    return [...this._banks.values()].find((bank) => bank.label === label) ?? null;
  }
  /**
   * Update instance data by fetching and storing the latest on-chain state.
   */
  getBankByPk(publicKey) {
    let _publicKey = translateAddress2(publicKey);
    return this._banks.get(_publicKey.toString()) ?? null;
  }
  getBankByMint(mint) {
    return [...this._banks.values()].find((bank) => bank.mint.equals(mint)) ?? null;
  }
};
var group_default = MarginfiGroup;

// src/client.ts
import {
  DEFAULT_COMMITMENT as DEFAULT_COMMITMENT3,
  DEFAULT_CONFIRM_OPTS,
  loadKeypair,
  NodeWallet
} from "@mrgnlabs/mrgn-common";
var MarginfiClient = class {
  /**
   * @internal
   */
  constructor(config, program, wallet, group) {
    this.config = config;
    this.program = program;
    this.wallet = wallet;
    this.programId = config.programId;
    this._group = group;
  }
  // --- Factories
  /**
   * MarginfiClient factory
   *
   * Fetch account data according to the config and instantiate the corresponding MarginfiAccount.
   *
   * @param config marginfi config
   * @param wallet User wallet (used to pay fees and sign transactions)
   * @param connection Solana web.js Connection object
   * @param opts Solana web.js ConfirmOptions object
   * @returns MarginfiClient instance
   */
  static async fetch(config, wallet, connection, opts) {
    const provider = new AnchorProvider(connection, wallet, {
      ...AnchorProvider.defaultOptions(),
      commitment: connection.commitment ?? AnchorProvider.defaultOptions().commitment,
      ...opts
    });
    const program = new Program(IDL, config.programId, provider);
    return new MarginfiClient(config, program, wallet, await group_default.fetch(config, program, opts?.commitment));
  }
  static async fromEnv(overrides) {
    const env = overrides?.env ?? process.env.MARGINFI_ENV;
    const connection = overrides?.connection ?? new Connection(process.env.MARGINFI_RPC_ENDPOINT, {
      commitment: DEFAULT_COMMITMENT3
    });
    const programId = overrides?.programId ?? new PublicKey4(process.env.MARGINFI_PROGRAM);
    const groupPk = overrides?.marginfiGroup ?? (process.env.MARGINFI_GROUP ? new PublicKey4(process.env.MARGINFI_GROUP) : PublicKey4.default);
    const wallet = overrides?.wallet ?? new NodeWallet(
      process.env.MARGINFI_WALLET_KEY ? Keypair.fromSecretKey(new Uint8Array(JSON.parse(process.env.MARGINFI_WALLET_KEY))) : loadKeypair(process.env.MARGINFI_WALLET)
    );
    const config = await getConfig(env, {
      groupPk: translateAddress3(groupPk),
      programId: translateAddress3(programId)
    });
    return MarginfiClient.fetch(config, wallet, connection, {
      commitment: connection.commitment
    });
  }
  // --- Getters and setters
  /**
   * Marginfi account group address
   */
  get group() {
    return this._group;
  }
  get provider() {
    return this.program.provider;
  }
  // --- Others
  /**
   * Create transaction instruction to create a new marginfi account under the authority of the user.
   *
   * @returns transaction instruction
   */
  async makeCreateMarginfiAccountIx(marginfiAccountKeypair) {
    const accountKeypair = marginfiAccountKeypair || Keypair.generate();
    const initMarginfiAccountIx = await instructions_default.makeInitMarginfiAccountIx(this.program, {
      marginfiGroupPk: this._group.publicKey,
      marginfiAccountPk: accountKeypair.publicKey,
      authorityPk: this.provider.wallet.publicKey,
      feePayerPk: this.provider.wallet.publicKey
    });
    const ixs = [initMarginfiAccountIx];
    return {
      instructions: ixs,
      keys: [accountKeypair]
    };
  }
  /**
   * Create a new marginfi account under the authority of the user.
   *
   * @returns MarginfiAccount instance
   */
  async createMarginfiAccount(opts) {
    const accountKeypair = Keypair.generate();
    const ixs = await this.makeCreateMarginfiAccountIx(accountKeypair);
    const tx = new Transaction2().add(...ixs.instructions);
    const sig = await this.processTransaction(tx, ixs.keys, opts);
    return opts?.dryRun ? Promise.resolve(void 0) : account_default.fetch(accountKeypair.publicKey, this, opts?.commitment);
  }
  /**
   * Retrieves the addresses of all marginfi accounts in the underlying group.
   *
   * @returns Account addresses
   */
  async getAllMarginfiAccountAddresses() {
    return (await this.program.provider.connection.getProgramAccounts(this.programId, {
      commitment: this.program.provider.connection.commitment,
      dataSlice: {
        offset: 0,
        length: 0
      },
      filters: [
        {
          memcmp: {
            bytes: this._group.publicKey.toBase58(),
            offset: 8
            // marginfiGroup is the second field in the account after the authority, so offset by the discriminant and a pubkey
          }
        },
        {
          memcmp: {
            offset: 0,
            bytes: bs58.encode(BorshAccountsCoder.accountDiscriminator("marginfiAccount" /* MarginfiAccount */))
          }
        }
      ]
    })).map((a) => a.pubkey);
  }
  /**
   * Retrieves all marginfi accounts under the specified authority.
   *
   * @returns MarginfiAccount instances
   */
  async getMarginfiAccountsForAuthority(authority) {
    const marginfiGroup = await group_default.fetch(this.config, this.program);
    const _authority = authority ? translateAddress3(authority) : this.provider.wallet.publicKey;
    return (await this.program.account.marginfiAccount.all([
      {
        memcmp: {
          bytes: this._group.publicKey.toBase58(),
          offset: 8
          // marginfiGroup is the first field in the account, so only offset is the discriminant
        }
      },
      {
        memcmp: {
          bytes: _authority.toBase58(),
          offset: 8 + 32
          // authority is the second field in the account after the authority, so offset by the discriminant and a pubkey
        }
      }
    ])).map((a) => account_default.fromAccountData(a.publicKey, this, a.account, marginfiGroup));
  }
  /**
   * Retrieves the addresses of all accounts owned by the marginfi program.
   *
   * @returns Account addresses
   */
  async getAllProgramAccountAddresses(type) {
    return (await this.program.provider.connection.getProgramAccounts(this.programId, {
      commitment: this.program.provider.connection.commitment,
      dataSlice: {
        offset: 0,
        length: 0
      },
      filters: [
        {
          memcmp: {
            offset: 0,
            bytes: bs58.encode(BorshAccountsCoder.accountDiscriminator(type))
          }
        }
      ]
    })).map((a) => a.pubkey);
  }
  async processTransaction(transaction, signers, opts) {
    let signature = "";
    console.log("client.ts");
    try {
      let versionedTransaction;
      const connection = new Connection(this.provider.connection.rpcEndpoint, this.provider.opts);
      const {
        context: { slot: minContextSlot },
        value: { blockhash, lastValidBlockHeight }
      } = await connection.getLatestBlockhashAndContext();
      if (transaction instanceof Transaction2) {
        const versionedMessage = new TransactionMessage({
          instructions: transaction.instructions,
          payerKey: this.provider.publicKey,
          recentBlockhash: blockhash
        });
        versionedTransaction = new VersionedTransaction(versionedMessage.compileToV0Message([]));
      } else {
        versionedTransaction = transaction;
      }
      versionedTransaction = await this.wallet.signTransaction(versionedTransaction);
      if (signers)
        versionedTransaction.sign(signers);
      if (opts?.dryRun) {
        const response = await connection.simulateTransaction(
          versionedTransaction,
          opts ?? { minContextSlot, sigVerify: false }
        );
        console.log(
          response.value.err ? `\u274C Error: ${response.value.err}` : `\u2705 Success - ${response.value.unitsConsumed} CU`
        );
        console.log("------ Logs \u{1F447} ------");
        console.log(response.value.logs);
        const signaturesEncoded = encodeURIComponent(
          JSON.stringify(versionedTransaction.signatures.map((s) => bs58.encode(s)))
        );
        const messageEncoded = encodeURIComponent(
          Buffer.from(versionedTransaction.message.serialize()).toString("base64")
        );
        console.log(Buffer.from(versionedTransaction.message.serialize()).toString("base64"));
        const urlEscaped = `https://explorer.solana.com/tx/inspector?cluster=${this.config.cluster}&signatures=${signaturesEncoded}&message=${messageEncoded}`;
        console.log("------ Inspect \u{1F447} ------");
        console.log(urlEscaped);
        return versionedTransaction.signatures[0].toString();
      } else {
        let mergedOpts = {
          ...DEFAULT_CONFIRM_OPTS,
          commitment: connection.commitment ?? DEFAULT_CONFIRM_OPTS.commitment,
          preflightCommitment: connection.commitment ?? DEFAULT_CONFIRM_OPTS.commitment,
          minContextSlot,
          ...opts
        };
        signature = await connection.sendTransaction(versionedTransaction, {
          minContextSlot: mergedOpts.minContextSlot,
          skipPreflight: mergedOpts.skipPreflight,
          preflightCommitment: mergedOpts.preflightCommitment,
          maxRetries: mergedOpts.maxRetries
        });
        await connection.confirmTransaction(
          {
            blockhash,
            lastValidBlockHeight,
            signature
          },
          mergedOpts.commitment
        );
        return signature;
      }
    } catch (error) {
      if (error.logs) {
        console.log("------ Logs \u{1F447} ------");
        console.log(error.logs.join("\n"));
      }
      throw `Transaction failed! ${error?.message}`;
    }
  }
};
var client_default = MarginfiClient;

// src/clientReadonly.ts
import { AnchorProvider as AnchorProvider2, BorshAccountsCoder as BorshAccountsCoder2, Program as Program2, translateAddress as translateAddress5 } from "@project-serum/anchor";
import { bs58 as bs582 } from "@project-serum/anchor/dist/cjs/utils/bytes";
import { Connection as Connection2, PublicKey as PublicKey5 } from "@solana/web3.js";

// src/accountReadonly.ts
import { BorshCoder as BorshCoder3, translateAddress as translateAddress4 } from "@project-serum/anchor";
import BigNumber4 from "bignumber.js";
import { DEFAULT_COMMITMENT as DEFAULT_COMMITMENT4, shortenAddress as shortenAddress2 } from "@mrgnlabs/mrgn-common";
var MarginfiAccountReadonly = class {
  /**
   * @internal
   */
  constructor(marginfiAccountPk, client, group, rawData) {
    this.client = client;
    this.publicKey = marginfiAccountPk;
    this._group = group;
    this._authority = rawData.authority;
    this._lendingAccount = rawData.lendingAccount.balances.map((la) => new Balance(la));
  }
  // --- Getters / Setters
  /**
   * Marginfi account authority address
   */
  get authority() {
    return this._authority;
  }
  /**
   * Marginfi group address
   */
  get activeBalances() {
    return this._lendingAccount.filter((la) => la.active);
  }
  get group() {
    return this._group;
  }
  /**
   * Marginfi group address
   */
  /** @internal */
  get _program() {
    return this.client.program;
  }
  /** @internal */
  get _config() {
    return this.client.config;
  }
  // --- Factories
  /**
   * MarginfiAccount network factory
   *
   * Fetch account data according to the config and instantiate the corresponding MarginfiAccount.
   *
   * @param marginfiAccountPk Address of the target account
   * @param client marginfi client
   * @param commitment Commitment level override
   * @returns MarginfiAccount instance
   */
  static async fetch(marginfiAccountPk, client, commitment) {
    const { config, program } = client;
    const _marginfiAccountPk = translateAddress4(marginfiAccountPk);
    const accountData = await MarginfiAccountReadonly._fetchAccountData(
      _marginfiAccountPk,
      config,
      program,
      commitment
    );
    const marginfiAccount = new MarginfiAccountReadonly(
      _marginfiAccountPk,
      client,
      await group_default.fetch(config, program, commitment),
      accountData
    );
    return marginfiAccount;
  }
  /**
   * MarginfiAccount local factory (decoded)
   *
   * Instantiate a MarginfiAccount according to the provided decoded data.
   * Check sanity against provided config.
   *
   * @param marginfiAccountPk Address of the target account
   * @param client marginfi client
   * @param accountData Decoded marginfi marginfi account data
   * @param marginfiGroup MarginfiGroup instance
   * @returns MarginfiAccount instance
   */
  static fromAccountData(marginfiAccountPk, client, accountData, marginfiGroup) {
    if (!accountData.group.equals(client.config.groupPk))
      throw Error(
        `Marginfi account tied to group ${accountData.group.toBase58()}. Expected: ${client.config.groupPk.toBase58()}`
      );
    const _marginfiAccountPk = translateAddress4(marginfiAccountPk);
    return new MarginfiAccountReadonly(_marginfiAccountPk, client, marginfiGroup, accountData);
  }
  /**
   * MarginfiAccount local factory (encoded)
   *
   * Instantiate a MarginfiAccount according to the provided encoded data.
   * Check sanity against provided config.
   *
   * @param marginfiAccountPk Address of the target account
   * @param client marginfi client
   * @param marginfiAccountRawData Encoded marginfi marginfi account data
   * @param marginfiGroup MarginfiGroup instance
   * @returns MarginfiAccount instance
   */
  static fromAccountDataRaw(marginfiAccountPk, client, marginfiAccountRawData, marginfiGroup) {
    const marginfiAccountData = MarginfiAccountReadonly.decode(marginfiAccountRawData);
    return MarginfiAccountReadonly.fromAccountData(marginfiAccountPk, client, marginfiAccountData, marginfiGroup);
  }
  // --- Others
  /**
   * Fetch marginfi account data.
   * Check sanity against provided config.
   *
   * @param accountAddress accountAddress Address of the target account
   * @param config marginfi config
   * @param program marginfi Anchor program
   * @param commitment Commitment level override
   * @returns Decoded marginfi account data struct
   */
  static async _fetchAccountData(accountAddress, config, program, commitment) {
    const mergedCommitment = commitment ?? program.provider.connection.commitment ?? DEFAULT_COMMITMENT4;
    const data = await program.account.marginfiAccount.fetch(
      accountAddress,
      mergedCommitment
    );
    if (!data.group.equals(config.groupPk))
      throw Error(`Marginfi account tied to group ${data.group.toBase58()}. Expected: ${config.groupPk.toBase58()}`);
    return data;
  }
  /**
   * Decode marginfi account data according to the Anchor IDL.
   *
   * @param encoded Raw data buffer
   * @returns Decoded marginfi account data struct
   */
  static decode(encoded) {
    const coder = new BorshCoder3(IDL);
    return coder.accounts.decode("marginfiAccount" /* MarginfiAccount */, encoded);
  }
  /**
   * Decode marginfi account data according to the Anchor IDL.
   *
   * @param decoded Marginfi account data struct
   * @returns Raw data buffer
   */
  static async encode(decoded) {
    const coder = new BorshCoder3(IDL);
    return await coder.accounts.encode("marginfiAccount" /* MarginfiAccount */, decoded);
  }
  /**
   * Update instance data by fetching and storing the latest on-chain state.
   */
  async reload() {
    const [marginfiGroupAi, marginfiAccountAi] = await this.loadGroupAndAccountAi();
    const marginfiAccountData = MarginfiAccountReadonly.decode(marginfiAccountAi.data);
    if (!marginfiAccountData.group.equals(this._config.groupPk))
      throw Error(
        `Marginfi account tied to group ${marginfiAccountData.group.toBase58()}. Expected: ${this._config.groupPk.toBase58()}`
      );
    const bankAccountsData = await this._program.account.bank.all([
      { memcmp: { offset: 8 + 32 + 1, bytes: this._config.groupPk.toBase58() } }
    ]);
    const banks = await Promise.all(
      bankAccountsData.map(async (accountData) => {
        let bankData = accountData.account;
        return new Bank(
          this._config.banks.find((b) => b.address.equals(accountData.publicKey))?.label || "Unknown",
          accountData.publicKey,
          bankData,
          await getOraclePriceData(
            this._program.provider.connection,
            bankData.config.oracleSetup,
            bankData.config.oracleKeys
          )
        );
      })
    );
    this._group = group_default.fromAccountDataRaw(this._config, this._program, marginfiGroupAi.data, banks);
    this._updateFromAccountData(marginfiAccountData);
  }
  /**
   * Update instance data from provided data struct.
   *
   * @param data Marginfi account data struct
   */
  _updateFromAccountData(data) {
    this._authority = data.authority;
    this._lendingAccount = data.lendingAccount.balances.map((la) => new Balance(la));
  }
  async loadGroupAndAccountAi() {
    let [marginfiGroupAi, marginfiAccountAi] = await this.client.provider.connection.getMultipleAccountsInfo(
      [this._config.groupPk, this.publicKey],
      DEFAULT_COMMITMENT4
    );
    if (!marginfiAccountAi) {
      throw Error("Marginfi account no found");
    }
    if (!marginfiGroupAi) {
      throw Error("Marginfi Group Account no found");
    }
    return [marginfiGroupAi, marginfiAccountAi];
  }
  getHealthComponents(marginReqType) {
    const [assets, liabilities] = this.activeBalances.map((accountBalance) => {
      const bank = this._group.banks.get(accountBalance.bankPk.toBase58());
      if (!bank)
        throw Error(`Bank ${shortenAddress2(accountBalance.bankPk)} not found`);
      const { assets: assets2, liabilities: liabilities2 } = accountBalance.getUsdValueWithPriceBias(bank, marginReqType);
      return [assets2, liabilities2];
    }).reduce(
      ([asset, liability], [d, l]) => {
        return [asset.plus(d), liability.plus(l)];
      },
      [new BigNumber4(0), new BigNumber4(0)]
    );
    return { assets, liabilities };
  }
  canBeLiquidated() {
    const { assets, liabilities } = this.getHealthComponents(1 /* Maint */);
    return assets < liabilities;
  }
  // Calculate the max withdraw of a lending account balance.
  // max_withdraw = max(free_collateral, balance_deposit) + max(free_collateral - balance_deposit, 0) / balance_liab_weight
  getMaxWithdrawForBank(_bank) {
    return new BigNumber4(0);
  }
};
var accountReadonly_default = MarginfiAccountReadonly;

// src/clientReadonly.ts
import { DEFAULT_COMMITMENT as DEFAULT_COMMITMENT5 } from "@mrgnlabs/mrgn-common";
var MarginfiClientReadonly = class {
  /**
   * @internal
   */
  constructor(config, program, group) {
    this.config = config;
    this.program = program;
    this.programId = config.programId;
    this._group = group;
  }
  // --- Factories
  /**
   * MarginfiClient factory
   *
   * Fetch account data according to the config and instantiate the corresponding MarginfiAccount.
   *
   * @param config marginfi config
   * @param connection Solana web.js Connection object
   * @param opts Solana web.js ConfirmOptions object
   * @returns MarginfiClient instance
   */
  static async fetch(config, connection, opts) {
    const provider = new AnchorProvider2(connection, {}, {
      ...AnchorProvider2.defaultOptions(),
      commitment: connection.commitment ?? AnchorProvider2.defaultOptions().commitment,
      ...opts
    });
    const program = new Program2(IDL, config.programId, provider);
    return new MarginfiClientReadonly(config, program, await group_default.fetch(config, program, opts?.commitment));
  }
  static async fromEnv(overrides) {
    const env = overrides?.env ?? process.env.MARGINFI_ENV;
    const connection = overrides?.connection ?? new Connection2(process.env.MARGINFI_RPC_ENDPOINT, {
      commitment: DEFAULT_COMMITMENT5
    });
    const programId = overrides?.programId ?? new PublicKey5(process.env.MARGINFI_PROGRAM);
    const groupPk = overrides?.marginfiGroup ?? (process.env.MARGINFI_GROUP ? new PublicKey5(process.env.MARGINFI_GROUP) : PublicKey5.default);
    const config = await getConfig(env, {
      groupPk: translateAddress5(groupPk),
      programId: translateAddress5(programId)
    });
    return MarginfiClientReadonly.fetch(config, connection, {
      commitment: connection.commitment
    });
  }
  // --- Getters and setters
  /**
   * Marginfi account group address
   */
  get group() {
    return this._group;
  }
  get provider() {
    return this.program.provider;
  }
  // --- Others
  /**
   * Retrieves the addresses of all marginfi accounts in the udnerlying group.
   *
   * @returns Account addresses
   */
  async getAllMarginfiAccountAddresses() {
    return (await this.program.provider.connection.getProgramAccounts(this.programId, {
      commitment: this.program.provider.connection.commitment,
      dataSlice: {
        offset: 0,
        length: 0
      },
      filters: [
        {
          memcmp: {
            bytes: this._group.publicKey.toBase58(),
            offset: 8 + 32
            // marginfiGroup is the second field in the account after the authority, so offset by the discriminant and a pubkey
          }
        },
        {
          memcmp: {
            offset: 0,
            bytes: bs582.encode(BorshAccountsCoder2.accountDiscriminator("marginfiAccount" /* MarginfiAccount */))
          }
        }
      ]
    })).map((a) => a.pubkey);
  }
  /**
   * Retrieves all marginfi accounts under the specified authority.
   *
   * @returns MarginfiAccount instances
   */
  async getMarginfiAccountsForAuthority(authority) {
    const marginfiGroup = await group_default.fetch(this.config, this.program);
    const _authority = translateAddress5(authority);
    return (await this.program.account.marginfiAccount.all([
      {
        memcmp: {
          bytes: _authority.toBase58(),
          offset: 8
          // authority is the first field in the account, so only offset is the discriminant
        }
      },
      {
        memcmp: {
          bytes: this._group.publicKey.toBase58(),
          offset: 8 + 32
          // marginfiGroup is the second field in the account after the authority, so offset by the discriminant and a pubkey
        }
      }
    ])).map(
      (a) => accountReadonly_default.fromAccountData(a.publicKey, this, a.account, marginfiGroup)
    );
  }
  /**
   * Retrieves the addresses of all accounts owned by the marginfi program.
   *
   * @returns Account addresses
   */
  async getAllProgramAccountAddresses(type) {
    return (await this.program.provider.connection.getProgramAccounts(this.programId, {
      commitment: this.program.provider.connection.commitment,
      dataSlice: {
        offset: 0,
        length: 0
      },
      filters: [
        {
          memcmp: {
            offset: 0,
            bytes: bs582.encode(BorshAccountsCoder2.accountDiscriminator(type))
          }
        }
      ]
    })).map((a) => a.pubkey);
  }
};
var clientReadonly_default = MarginfiClientReadonly;

// src/utils.ts
import { PublicKey as PublicKey6 } from "@solana/web3.js";
function getBankVaultSeeds(type) {
  switch (type) {
    case 0 /* LiquidityVault */:
      return PDA_BANK_LIQUIDITY_VAULT_SEED;
    case 1 /* InsuranceVault */:
      return PDA_BANK_INSURANCE_VAULT_SEED;
    case 2 /* FeeVault */:
      return PDA_BANK_FEE_VAULT_SEED;
    default:
      throw Error(`Unknown vault type ${type}`);
  }
}
function getBankVaultAuthoritySeeds(type) {
  switch (type) {
    case 0 /* LiquidityVault */:
      return PDA_BANK_LIQUIDITY_VAULT_AUTH_SEED;
    case 1 /* InsuranceVault */:
      return PDA_BANK_INSURANCE_VAULT_AUTH_SEED;
    case 2 /* FeeVault */:
      return PDA_BANK_FEE_VAULT_AUTH_SEED;
    default:
      throw Error(`Unknown vault type ${type}`);
  }
}
function getBankVaultAuthority(bankVaultType, bankPk, programId) {
  return PublicKey6.findProgramAddressSync([getBankVaultAuthoritySeeds(bankVaultType), bankPk.toBuffer()], programId);
}
export {
  AccountType,
  Balance,
  Bank,
  BankVaultType,
  IDL as MARGINFI_IDL,
  MarginRequirementType,
  account_default as MarginfiAccount,
  client_default as MarginfiClient,
  clientReadonly_default as MarginfiClientReadonly,
  group_default as MarginfiGroup,
  OracleSetup,
  PDA_BANK_FEE_VAULT_AUTH_SEED,
  PDA_BANK_FEE_VAULT_SEED,
  PDA_BANK_INSURANCE_VAULT_AUTH_SEED,
  PDA_BANK_INSURANCE_VAULT_SEED,
  PDA_BANK_LIQUIDITY_VAULT_AUTH_SEED,
  PDA_BANK_LIQUIDITY_VAULT_SEED,
  PYTH_PRICE_CONF_INTERVALS,
  PriceBias,
  SWB_PRICE_CONF_INTERVALS,
  USDC_DECIMALS,
  getBankVaultAuthority,
  getBankVaultSeeds,
  getConfig,
  getOraclePriceData
};
//# sourceMappingURL=index.mjs.map