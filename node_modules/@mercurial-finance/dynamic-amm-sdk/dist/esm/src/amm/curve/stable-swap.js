import { BN, BorshCoder } from '@project-serum/anchor';
import { computeD, computeY, normalizedTradeFee } from '@saberhq/stableswap-sdk';
import { Fraction, Percent, ZERO } from '@saberhq/token-utils';
import { PublicKey } from '@solana/web3.js';
import JSBI from 'jsbi';
import { TradeDirection, getPriceImpact } from '.';
import { CURVE_TYPE_ACCOUNTS } from '../constants';
import MarinadeIDL from '../marinade-finance.json';
import { StakePoolLayout } from '../types';
// Precision for base pool virtual price
const PRECISION = new BN(1000000);
const BASE_CACHE_EXPIRE = new BN(60 * 10);
const N_COINS = JSBI.BigInt(2);
export class StableSwap {
    constructor(amp, tokenMultiplier, depeg, extraAccounts, onChainTime, stakePoolPubkey) {
        this.amp = amp;
        this.tokenMultiplier = tokenMultiplier;
        this.depeg = depeg;
        this.extraAccounts = extraAccounts;
        this.onChainTime = onChainTime;
        this.stakePoolPubkey = stakePoolPubkey;
    }
    getBasePoolVirtualPrice(depegType) {
        if (depegType['marinade']) {
            const account = this.extraAccounts.get(CURVE_TYPE_ACCOUNTS.marinade.toBase58());
            const coder = new BorshCoder(MarinadeIDL);
            const stake = coder.accounts.decode('State', account.data);
            const msolPrice = stake.msolPrice;
            return msolPrice.mul(PRECISION).div(new BN(4294967296));
        }
        if (depegType['lido']) {
            const account = this.extraAccounts.get(CURVE_TYPE_ACCOUNTS.lido.toBase58());
            //https://github.com/mercurial-finance/mercurial-dynamic-amm/blob/main/programs/amm/tests/test_depeg_price.rs#L33
            const stSolSupply = new BN(account.data.readBigInt64LE(73).toString());
            const stSolBalance = new BN(account.data.readBigInt64LE(81).toString());
            return stSolBalance.mul(PRECISION).div(stSolSupply);
        }
        if (depegType['splStake']) {
            const account = this.extraAccounts.get(this.stakePoolPubkey.toBase58());
            const stakePool = StakePoolLayout.decode(account.data);
            return stakePool.totalLamports.mul(PRECISION).div(stakePool.poolTokenSupply);
        }
        throw new Error('UnsupportedBasePool');
    }
    updateDepegInfoIfExpired() {
        if (!this.depeg.depegType['none']) {
            const expired = this.onChainTime.toNumber() > this.depeg.baseCacheUpdated.add(BASE_CACHE_EXPIRE).toNumber();
            if (expired) {
                this.depeg.baseVirtualPrice = this.getBasePoolVirtualPrice(this.depeg.depegType);
                this.depeg.baseCacheUpdated = new BN(this.onChainTime);
            }
        }
    }
    upscaleTokenA(tokenAAmount) {
        const { tokenAMultiplier } = this.tokenMultiplier;
        const normalizedTokenAAmount = tokenAAmount.mul(tokenAMultiplier);
        if (!this.depeg.depegType['none']) {
            return normalizedTokenAAmount.mul(PRECISION);
        }
        return normalizedTokenAAmount;
    }
    downscaleTokenA(tokenAAmount) {
        const { tokenAMultiplier } = this.tokenMultiplier;
        const denormalizedTokenAAmount = tokenAAmount.div(tokenAMultiplier);
        if (!this.depeg.depegType['none']) {
            return denormalizedTokenAAmount.div(PRECISION);
        }
        return denormalizedTokenAAmount;
    }
    upscaleTokenB(tokenBAmount) {
        const { tokenBMultiplier } = this.tokenMultiplier;
        const normalizedTokenBAmount = tokenBAmount.mul(tokenBMultiplier);
        if (!this.depeg.depegType['none']) {
            return normalizedTokenBAmount.mul(this.depeg.baseVirtualPrice);
        }
        return normalizedTokenBAmount;
    }
    downscaleTokenB(tokenBAmount) {
        const { tokenBMultiplier } = this.tokenMultiplier;
        const denormalizedTokenBAmount = tokenBAmount.div(tokenBMultiplier);
        if (!this.depeg.depegType['none']) {
            return denormalizedTokenBAmount.div(this.depeg.baseVirtualPrice);
        }
        return denormalizedTokenBAmount;
    }
    computeOutAmountWithoutSlippage(sourceAmount, swapSourceAmount, swapDestinationAmount, invariantD) {
        const SIXTEEN = new BN(16);
        const FOUR = new BN(4);
        const TWO = new BN(2);
        const amp = new BN(this.amp);
        const a = amp.mul(SIXTEEN);
        const b = a;
        const c = invariantD.mul(FOUR).sub(invariantD.mul(amp).mul(SIXTEEN));
        const numerator = TWO.mul(a)
            .mul(swapSourceAmount)
            .add(b.mul(swapDestinationAmount))
            .add(c)
            .mul(swapDestinationAmount);
        const denominator = a.mul(swapSourceAmount).add(TWO.mul(b).mul(swapDestinationAmount).add(c)).mul(swapSourceAmount);
        return sourceAmount.mul(numerator).div(denominator);
    }
    computeOutAmount(sourceAmount, swapSourceAmount, swapDestinationAmount, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledSourceAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount] = tradeDirection == TradeDirection.AToB
            ? [
                this.upscaleTokenA(sourceAmount),
                this.upscaleTokenA(swapSourceAmount),
                this.upscaleTokenB(swapDestinationAmount),
            ]
            : [
                this.upscaleTokenB(sourceAmount),
                this.upscaleTokenB(swapSourceAmount),
                this.upscaleTokenA(swapDestinationAmount),
            ];
        const invariantD = computeD(JSBI.BigInt(this.amp), JSBI.BigInt(upscaledSwapSourceAmount.toString()), JSBI.BigInt(upscaledSwapDestinationAmount.toString()));
        const newSwapSourceAmount = JSBI.add(JSBI.BigInt(upscaledSwapSourceAmount.toString()), JSBI.BigInt(upscaledSourceAmount.toString()));
        const newSwapDestinationAmount = computeY(JSBI.BigInt(this.amp), newSwapSourceAmount, invariantD);
        let outAmount = upscaledSwapDestinationAmount.sub(new BN(newSwapDestinationAmount.toString())).sub(new BN(1));
        let outAmountWithoutSlippage = this.computeOutAmountWithoutSlippage(upscaledSourceAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount, new BN(invariantD.toString()));
        [outAmount, outAmountWithoutSlippage] =
            tradeDirection == TradeDirection.AToB
                ? [this.downscaleTokenB(outAmount), this.downscaleTokenB(outAmountWithoutSlippage)]
                : [this.downscaleTokenA(outAmount), this.downscaleTokenA(outAmountWithoutSlippage)];
        return {
            outAmount,
            priceImpact: getPriceImpact(outAmount, outAmountWithoutSlippage),
        };
    }
    computeD(tokenAAmount, tokenBAmount) {
        this.updateDepegInfoIfExpired();
        const upscaledTokenAAmount = this.upscaleTokenA(tokenAAmount);
        const upscaledTokenBAmount = this.upscaleTokenB(tokenBAmount);
        const invariantD = new BN(computeD(JSBI.BigInt(this.amp), JSBI.BigInt(upscaledTokenAAmount.toString()), JSBI.BigInt(upscaledTokenBAmount.toString())).toString());
        if (!this.depeg.depegType['none']) {
            return invariantD.div(PRECISION);
        }
        return invariantD;
    }
    computeInAmount(destAmount, swapSourceAmount, swapDestinationAmount, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledDestAmount, upscaledSwapSourceAmount, upscaledSwapDestinationAmount] = tradeDirection == TradeDirection.AToB
            ? [
                this.upscaleTokenB(destAmount),
                this.upscaleTokenA(swapSourceAmount),
                this.upscaleTokenB(swapDestinationAmount),
            ]
            : [
                this.upscaleTokenA(destAmount),
                this.upscaleTokenB(swapSourceAmount),
                this.upscaleTokenA(swapDestinationAmount),
            ];
        const invariantD = computeD(JSBI.BigInt(this.amp), JSBI.BigInt(upscaledSwapSourceAmount.toString()), JSBI.BigInt(upscaledSwapDestinationAmount.toString()));
        const newSwapDestAmount = JSBI.subtract(JSBI.BigInt(upscaledSwapDestinationAmount.toString()), JSBI.BigInt(upscaledDestAmount.toString()));
        const newSwapSourceAmount = computeY(JSBI.BigInt(this.amp), newSwapDestAmount, invariantD);
        const inAmount = new BN(newSwapSourceAmount.toString()).sub(swapSourceAmount);
        return tradeDirection == TradeDirection.AToB ? this.downscaleTokenA(inAmount) : this.downscaleTokenB(inAmount);
    }
    computeImbalanceDeposit(depositAAmount, depositBAmount, swapTokenAAmount, swapTokenBAmount, lpSupply, fees) {
        this.updateDepegInfoIfExpired();
        const [upscaledDepositAAmount, upscaledDepositBAmount, upscaledSwapTokenAAmount, upscaledSwapTokenBAmount] = [
            this.upscaleTokenA(depositAAmount),
            this.upscaleTokenB(depositBAmount),
            this.upscaleTokenA(swapTokenAAmount),
            this.upscaleTokenB(swapTokenBAmount),
        ];
        const { mintAmount } = calculateEstimatedMintAmount(JSBI.BigInt(this.amp), Helper.toFees(fees), JSBI.BigInt(lpSupply.toString()), [JSBI.BigInt(upscaledSwapTokenAAmount.toString()), JSBI.BigInt(upscaledSwapTokenBAmount.toString())], JSBI.BigInt(upscaledDepositAAmount.toString()), JSBI.BigInt(upscaledDepositBAmount.toString()));
        return new BN(mintAmount.toString());
    }
    computeWithdrawOne(lpAmount, lpSupply, swapTokenAAmount, swapTokenBAmount, fees, tradeDirection) {
        this.updateDepegInfoIfExpired();
        const [upscaledSwapTokenAAmount, upscaledSwapTokenBAmount] = [
            this.upscaleTokenA(swapTokenAAmount),
            this.upscaleTokenB(swapTokenBAmount),
        ];
        const { withdrawAmountBeforeFees } = calculateEstimatedWithdrawOneAmount({
            ampFactor: JSBI.BigInt(this.amp),
            feeInfo: Helper.toFees(fees),
            lpTotalSupply: JSBI.BigInt(lpSupply.toString()),
            poolTokenAmount: JSBI.BigInt(lpAmount.toString()),
            reserves: [JSBI.BigInt(upscaledSwapTokenAAmount.toString()), JSBI.BigInt(upscaledSwapTokenBAmount.toString())],
            tradeDirection,
        });
        // Before withdrawal fee
        return tradeDirection == TradeDirection.AToB
            ? this.downscaleTokenB(new BN(withdrawAmountBeforeFees.toString()))
            : this.downscaleTokenA(new BN(withdrawAmountBeforeFees.toString()));
    }
    getRemainingAccounts() {
        let accounts = [];
        if ('marinade' in this.depeg.depegType) {
            accounts.push({
                pubkey: CURVE_TYPE_ACCOUNTS.marinade,
                isWritable: false,
                isSigner: false,
            });
        }
        if ('lido' in this.depeg.depegType) {
            accounts.push({
                pubkey: CURVE_TYPE_ACCOUNTS.lido,
                isWritable: false,
                isSigner: false,
            });
        }
        if (!this.stakePoolPubkey.equals(PublicKey.default)) {
            accounts.push({
                pubkey: this.stakePoolPubkey,
                isWritable: false,
                isSigner: false,
            });
        }
        return accounts;
    }
}
function calculateEstimatedWithdrawOneAmount({ ampFactor, feeInfo, lpTotalSupply, reserves, poolTokenAmount, tradeDirection, }) {
    if (JSBI.equal(poolTokenAmount, ZERO)) {
        return {
            withdrawAmount: ZERO,
            withdrawAmountBeforeFees: ZERO,
            swapFee: ZERO,
            withdrawFee: ZERO,
            lpSwapFee: ZERO,
            lpWithdrawFee: ZERO,
            adminSwapFee: ZERO,
            adminWithdrawFee: ZERO,
        };
    }
    const [baseReserves, quoteReserves] = tradeDirection == TradeDirection.BToA ? [reserves[0], reserves[1]] : [reserves[1], reserves[0]];
    const d_0 = computeD(ampFactor, baseReserves, quoteReserves);
    const d_1 = JSBI.subtract(d_0, JSBI.divide(JSBI.multiply(poolTokenAmount, d_0), lpTotalSupply));
    const new_y = computeY(ampFactor, quoteReserves, d_1);
    // expected_base_amount = swap_base_amount * d_1 / d_0 - new_y;
    const expected_base_amount = JSBI.subtract(JSBI.divide(JSBI.multiply(baseReserves, d_1), d_0), new_y);
    // expected_quote_amount = swap_quote_amount - swap_quote_amount * d_1 / d_0;
    const expected_quote_amount = JSBI.subtract(quoteReserves, JSBI.divide(JSBI.multiply(quoteReserves, d_1), d_0));
    // new_base_amount = swap_base_amount - expected_base_amount * fee / fee_denominator;
    const new_base_amount = new Fraction(baseReserves.toString(), 1).subtract(normalizedTradeFee(feeInfo, N_COINS, expected_base_amount));
    // new_quote_amount = swap_quote_amount - expected_quote_amount * fee / fee_denominator;
    const new_quote_amount = new Fraction(quoteReserves.toString(), 1).subtract(normalizedTradeFee(feeInfo, N_COINS, expected_quote_amount));
    const dy = new_base_amount.subtract(computeY(ampFactor, JSBI.BigInt(new_quote_amount.toFixed(0)), d_1).toString());
    const dy_0 = JSBI.subtract(baseReserves, new_y);
    // lp fees
    const swapFee = new Fraction(dy_0.toString(), 1).subtract(dy);
    const withdrawFee = dy.multiply(feeInfo.withdraw.asFraction);
    // admin fees
    const adminSwapFee = swapFee.multiply(feeInfo.adminTrade.asFraction);
    const adminWithdrawFee = withdrawFee.multiply(feeInfo.adminWithdraw.asFraction);
    // final LP fees
    const lpSwapFee = swapFee.subtract(adminSwapFee);
    const lpWithdrawFee = withdrawFee.subtract(adminWithdrawFee);
    // final withdraw amount
    const withdrawAmount = dy.subtract(withdrawFee).subtract(swapFee);
    // final quantities
    return {
        withdrawAmount: JSBI.BigInt(withdrawAmount.toFixed(0)),
        withdrawAmountBeforeFees: JSBI.BigInt(dy.toFixed(0)),
        swapFee: JSBI.BigInt(swapFee.toFixed(0)),
        withdrawFee: JSBI.BigInt(withdrawFee.toFixed(0)),
        lpSwapFee: JSBI.BigInt(lpSwapFee.toFixed(0)),
        lpWithdrawFee: JSBI.BigInt(lpWithdrawFee.toFixed(0)),
        adminSwapFee: JSBI.BigInt(adminSwapFee.toFixed(0)),
        adminWithdrawFee: JSBI.BigInt(adminWithdrawFee.toFixed(0)),
    };
}
function calculateEstimatedMintAmount(ampFactor, feeInfo, lpTotalSupply, reserves, depositAmountA, depositAmountB) {
    if (JSBI.equal(depositAmountA, ZERO) && JSBI.equal(depositAmountB, ZERO)) {
        return {
            mintAmountBeforeFees: ZERO,
            mintAmount: ZERO,
            fees: ZERO,
        };
    }
    const amp = ampFactor;
    const [reserveA, reserveB] = reserves;
    const d0 = computeD(amp, reserveA, reserveB);
    const d1 = computeD(amp, JSBI.add(reserveA, depositAmountA), JSBI.add(reserveB, depositAmountB));
    if (JSBI.lessThan(d1, d0)) {
        throw new Error('New D cannot be less than previous D');
    }
    const oldBalances = reserves.map((r) => r);
    const newBalances = [JSBI.add(reserveA, depositAmountA), JSBI.add(reserveB, depositAmountB)];
    const adjustedBalances = newBalances.map((newBalance, i) => {
        const oldBalance = oldBalances[i];
        const idealBalance = new Fraction(d1, d0).multiply(oldBalance);
        const difference = idealBalance.subtract(newBalance);
        const diffAbs = difference.greaterThan(0) ? difference : difference.multiply(-1);
        const fee = normalizedTradeFee(feeInfo, N_COINS, JSBI.BigInt(diffAbs.toFixed(0)));
        return JSBI.subtract(newBalance, JSBI.BigInt(fee.toFixed(0)));
    });
    const d2 = computeD(amp, adjustedBalances[0], adjustedBalances[1]);
    const lpSupply = lpTotalSupply;
    const mintAmountRaw = JSBI.divide(JSBI.multiply(lpSupply, JSBI.subtract(d2, d0)), d0);
    const mintAmountRawBeforeFees = JSBI.divide(JSBI.multiply(lpSupply, JSBI.subtract(d1, d0)), d0);
    const fees = JSBI.subtract(mintAmountRawBeforeFees, mintAmountRaw);
    return {
        mintAmount: mintAmountRaw,
        mintAmountBeforeFees: mintAmountRawBeforeFees,
        fees,
    };
}
// Helper class to convert the type to the type from saber stable calculator
class Helper {
    static toFees(fees) {
        return {
            adminTrade: new Percent(fees.protocolTradeFeeNumerator, fees.protocolTradeFeeDenominator),
            trade: new Percent(fees.tradeFeeNumerator, fees.tradeFeeDenominator),
            adminWithdraw: new Percent(0, 100),
            withdraw: new Percent(0, 100),
        };
    }
}
//# sourceMappingURL=stable-swap.js.map